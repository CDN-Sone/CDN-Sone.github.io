{"posts":[{"title":"AQS与JUC","text":"在读这篇文章之前最好读读我前面的这篇文章：Java并发编程。 在这篇文章中我打算详细讲讲JUC包的几种锁，后面再补上AQS的源码分析。 首先我们明确一个区别，synchronized是由java JVM实现的，而Lock是由java JDK实现的。以下列了几个不同点 Synchronized是Java的内置关键字，Lock是一个java接口。 Synchronized无法判断获取锁的状态，Lock可以通过java.lang.Thread 中的holdsLock()方法判断是否获得某个对象的锁。 Synchronized会自动释放锁，Lock必须手动释放锁，否则可能产生死锁（手动使用lock和unlock方法）。 如果一个线程获得了锁，对于Synchronized来说其他需要使用这个资源的线程就只能等待下去，如果获得了锁的线程进入阻塞状态，其他线程依旧会等待，Lock锁就不一定会一直等待下去，可以通过tryLock尝试获取锁（线程是否等待）。 Synchronized是可重入锁，不可以中断，非公平的，Lock可重入锁，可以判断锁的状态，是否公平可以通过fair参数进行设置，相对而言比较灵活。 概述 首先我们从JUC包开始 我们首先了解JUC包下的几种锁 ReentrantLock重入锁 重入锁可以完全替代 synchronized 关键字。在java早期版本中，重入锁的性能远大于synchronized。但从JDK6.0开始，JDK在synchronized上做了大量的优化，使得两者的性能差距并不大。重入锁对逻辑控制的灵活性要远远好于synchronized。 使用方法比较简单： 123public ReentrantLock lock = new ReentrantLock();lock.lock();lock.unlock(); 这里注意，每个unlock()必须对应一个lock(),必须形成闭包。若unlock()数大于lock()数，则会抛出异常。 中断响应lockInterruptibly() 如果使用 synchronized ，要么获得锁，要么保持等待。而如果使用了重入锁，则提供了另一种可能，那就是线程可以被中断。也就是在等待锁的过程中，程序可以根据需要取消对锁的请求。即：如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待，可以停止工作了。 而使用synchronized的锁要想停止线程，必须先获得锁，才能继续继续执行 123456789101112131415161718192021static class ReentrantLockThread implements Runnable { private ReentrantLock lock; public ReentrantLockThread(ReentrantLock lock) { this.lock = lock } @Override public void run() { try { lock.lockInterruptibly(); // 获得lock1的可中断锁 System.out.println(Thread.currentThread().getName() + &quot;，加锁成功！&quot;); } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + &quot;，发生异常！&quot;); e.printStackTrace(); } finally { lock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;，lock解锁成功！&quot;); } }} 使用lockInterruptibly(),既是获取中断锁，若在此过程中发生异常，进程可以直接退出，这样的设计可以防止发生死锁。 tryLock(long time, TimeUnit unit) 1lock.tryLock(500, TimeUnit.MILLISECONDS) 该方法为在一定时间内试图获取锁，失败则返回。 tryLock()方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回true。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回false。 公平锁和非公平锁 在默认的情况下，锁的申请是非公平锁。我们知道sychronized在进入waitqueue时都会先经过几轮空循环,这个线程是有权利进行锁的争抢，所以sychronized锁是非公平的。 在默认情况下，ReentrantLock同样是非公平的，默认输入参数为false,当输入参数为true时，锁会转换成公平锁。公平锁默认会维护一个队列，这个我们以后再讲。 Condition重入锁 在使⽤内置锁synchronized时，通过调⽤Objec中定义的监视器⽅法，主要有wait(),wait(long timeout),notify()和notifyAll()⽅法，可以实现等待/通知模式。Codition接⼝中也定义了类似的监视器⽅法，与显示锁Lock配合使⽤也可以实现等待/ 通知模式。 常用方法方式如下 123Condition.await() //等待线程Condition.signal() //唤醒一个线程Condition.signalAll() //唤醒所有线程 Semaphore 信号量 synchronized和ReentrantLock机制都只允许获取锁（锁资源只有一个）的线程去访问资源，换而言之，只允许一个线程去访问资源。而Semaphore扩展了这种机制，可以指定多个线程同时访问某一个资源。 常用方法如下： 1234567891011void acquire(); //尝试获得⼀个准⼊的许可。若⽆法获得，则线程会等待，直到有线程释放⼀个 许可或者当前线程被中断。 void acquireUninterruptibly(); //具有acquire⼀样的功能，但是不响应中断 （Uninterruptibly）。 void tryAcquire(); //尝试获得⼀个许可，如果成功就⽴即返回true，失败则⽴即返回false。 void tryAcquire(long timeout, TimeUnit unit); //在指定时间内，尝试获得⼀个许可，如果成功 就返回true，失败则返回false。 void release(); 资源访问结束后，释放⼀个许可。 CountDownLatch倒计时器 CountDownLatch是⼀个多线程控制⼯具。⽤来控制线程的等待。设置需要countDown的数量num，然后每⼀个线程执⾏完毕后，调⽤countDown()⽅法，⽽主线程调⽤await()⽅ 法执⾏等待，直到num个⼦线程执⾏了countDown()⽅法 ，则主线程开始继续执⾏。 这个有点类似线程控制包里的join()方法。 ReadWriteLoc读写锁 ReadWriteLock由JDK5提供，它允许多个线程同时读。但是考虑到数据的完整性，写写操作和读写操作间依然是需要相互等待和持有锁的。 读 写 读 非阻塞 阻塞 读 阻塞 阻塞 如果在系统中，读操作的次数远远⼤于写操作，那么读写锁就可以发挥最⼤的效果， 提升系统的性能 CyclicBarrier循环栅栏 CyclicBarrier与CountDownLatch⾮常类似，它⽀持计数器的反复使⽤，CyclicBarrier可以理解为循环栅栏。CyclicBarrier可以接收⼀个参数作为Runnable barrierAction，每当计数器⼀次计数完成后——CyclicBarrier.await()时，系统会执⾏的动作。 LockSupport线程阻塞⼯具类 在之前的笔记中我们知道Thread.suspent,Thread.resume已经被废弃了，原因是如果使用不当，当先执行resume,后执行suspend将导致线程被永久阻塞。LockSupport类改善了这一情况，同时相比于使用监视器wait()或者Condition.await(),LockSupport不需要事先获取锁。 LockSupport包含两个方法，part,unpart。我们看看LockSupport是如何实现防止先调用unpart,后调用part导致线程被永远阻塞。 每⼀个线程都有⼀个许可，该许可默认为 不可⽤。如 果该许可是可⽤状态，那么park()⽅法会⽴即返回，消费这个许可，将该许可变更为不可⽤状态，流程代码可以继续执⾏。如果该许可是不可⽤状态，那么park()⽅法 将会阻塞；unpark⽅法，将指定线程的⼀个许可变为可⽤状态。 状态变化如表所示： 当前许可状态 调用后许可状态 park 可用 不可用 park 不可用 阻塞 unpark 可用 可用 unpark 不可用 可用 简而言之，经过unpart操作除阻塞状态变成非阻塞状态,其他所有状态都会变成可用状态，而当状态为不可用时是正常状态，若为可用，说明前面经过一次unpark,则调用park会将状态变回不可用状态。 同时注意park阻塞线程支持被中断，且中断后不会抛出InterruptedException异常。","link":"2024/06/04/AQS%E4%B8%8EJUC/"},{"title":"Kafka应用及其原理","text":"这章将会介绍消息队列中间件，本章除了介绍Kafka中间件还会介绍几种常见的中间件。在学习中间件的时候一定要注意横向选型能力。 常用的MQ介绍 Kafka 概述： 最初由LinkedIn公司基于独特的设计实现为一个分布式的日志提交系统。(要求快，但是允许低丢失)。 其性能高效（快），可扩展性好（很多公司选择在此结构上扩展），可持久化，且分区特性使其可复制、容错均不错。 优点： 客户端支持的语言丰富。 高性能：单机写入TPS约在100万条/秒，消息大小10个字节。 消费者采用Pull方式获取消息。消息有序，通过控制能够保证所有消息被消费且仅被消费一次。 缺点： Kafka单机超过64个队列/分区时，Load时会发生明显的飙高现象。队列越多，负载越高，发送消息响应时间变长。 使用短轮询方式，实时性取决于轮询间隔时间。 消费失败不支持重试。 RocketMQ 概述：RocketMQ出自阿里的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进（支持几十种消息收发的方式，串行，阻塞式，基于sql等等），消息可靠性上比Kafka更好。 RabbitMQ 概述：稳定性极高，用户界面非常友好。它提供了多种技术可以让你在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制；灵活的路由，消息在到达队列前是通过交换机进行路由的。 Kafka配置 属性 默认值 描述 broker.id 0 每个broker的唯一标志符 ｜ log.dirs /tmp/kafka-logs kafka存放数据的路径 ｜ listeners PLAINTEXT://192.168.65.60.9092 kafka的监听ip zookerper.connect localhost:2181 zk集群中的节点 num.partitions 1 创建topic的默认分区数 default.replication.factor 1 自动创建topic的默认副本数量，建立设置为大于等于2 ｜ min.insync.replicas ｜ 1 ｜ 指定消息成功写入时，最小的副本同步数量 ｜ 基本概念 名词 解释 Broker 【节点】一个Kafka节点就是一个Broker，一个和多个Broker可以组成一个Kafka集群 Topic 【主题】Kafka根据topic对消息进行归类，发布到kafka集群的每套消息都需要指定一个topic，topic是一个逻辑概念，物理上是不存在的 Producer 【生产者】用于向Kafka中发送消息 Consumer 【消费者】从Kafka中获取消息 Consumer Group 【消费组】每个Consumer都会归属于一个消费组，一条消息可以同时被多个不同的消费组消费，但是只能被一个消费组中的消费者消费 Partition 【分片】物理上的概念，可以将一个topic上的数据拆分为多分放到Partition中，每个Patition内部的消息是有序的。 Kafka的存储结构 消息是会被存储在kafka中的文件里的，并且是顺序存储的，消息有偏移量的概念，所以我们可以指定偏移量去读取某个位置的消息。 单播消息和多播消息 所谓的单播消息和多播消息就是根据消费者是否在统一消费组中消费组中。 单播消息 概述：一个消费组里，只会有一个消费者能够消费到某个topic中的消息。 多播消息 概述：一个topic下单消息被多个消费者消费。 架构图如下（引自JavaGuide） 稀疏索引 kafka收发消息速度快，那么在底层Kafka是如何存储消息的呢？在Kafka内部消息都是存在磁盘里的，所有的消息按照顺序写入磁盘（我们知道磁盘读写是慢于内存读写的。但是磁盘的顺序读写实际上和内存读写的速度差不多，而随机读写远远的慢于内存。Kafka使用在内存中顺序读写消息，使得消息收发快）。内部索引结构如下： Kafka集群 这里有几个概念注意下： 分区：一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。 副本：那么为了提高系统的可用性。我们把分片复制多个，这就是副本了。 Leader:kafka的读写操作都发生在leader上，leader负责把数据同步给follower。若Leader挂掉了，那么经过主从选举，从多个follower中选举产生一个新的leader。 Follower:follower接收leader同步过来的数据，它不提供读写（主要是为了保证多副本数据与消费的一致性） 多分区消费组 消息队列模型如下，（引自javaguide） 在每个topic中，存在一个或多个partition。为了维护消息的有序性一个partition只能被一个消费组中的一个消费者消费（同一组的消费者消费消息是互斥），但是在多个partition的多个消费者消费的总顺序性是无法得到保证的（从这里可以看出如果要实现消息的有序性，用一个partition就可以了）。 partition的数量决定了消费组中Consumer的数量，建议同一个消费组中的Consumer数量不要超过partition的数量，否则多余的Consumer就无法消费到消息了。但是，如果消费者挂掉了，那么就会触发rebalance机制，会由其他消费者来消费该分区。 重平衡（Rebalance） 在重平衡之前，一个consumer gruop中有多个consumer组成，一个topic有多个partition组成，如何确定哪个consumer消费哪个分区？消费者消费有三种策略。 Range：通过公式来计算某个消费者消费哪个分区 RoundRobin：大家轮流对分区进行消费 sticky：在触发rebalance之后，在消费者消费的原分区不变的基础上进行调整。 controller 概述：Kafka集群中的Broker在ZK中创建临时序号节点，序号最小的节点也就是最先创建的那个节点，将作为集群的Controller，负责管理整个集群中的所有分区和副本的状态。 八股 如何防止消息丢失 对于发送方： 将ack设置为1或者-1/all可以防止消息丢失，如果要做到99.9999%，ack要设置为-1/all。 针对消费方： 把自动提交修改为手动提交。（防止消费异常，导致消息丢失） acks 消息持久化机制 -1/all acks=all就意味着ISR列表里面的副本必须都要同步成功，才返回ack给消息队列，min.insync.replicas 这个配置是用来设置同步副本个数的下限，此时这个配置无效 0 表示producer不需要等待任何broker确认收到消息的ACK回复，就可以继续发送下一条消息。性能最高，但是最容易丢失消息 1 表示至少等待leader已经成功将数据写入本地日志，但是不需要等待所有follower都写入成功，就可以继续发送下一条消息。 针对接收方： 防止消息的重复消费 加入幂等处理： 通过mysql插入业务id作为主键，因为主键具有唯一性，所以一次只能插入一条业务数据。 使用redis或zk的分布式锁，实现对业务数据的幂等操作。 实现顺序消费 发送方：当收到ack时才继续发送消息，但只能保证，topic里面是有序的。 接收方；在topic里只配置一个partition，或者consumer组里只有一个consumer 解决消息积压问题 解决思路：消息积压是因为消费者处理速度太慢，从消费者端进行处理。 消费者采用多线程，或者增加消费者数量。 对消费逻辑设置最大处理时延，即进行熔断降级。 实现单机下的高并发吞吐量 写入数据：页面缓存技术 + 磁盘顺序写 读取数据：零拷贝技术 简单看一下零拷贝技术和非零拷贝技术的区别 零拷贝技术： 非零拷贝技术： 可以看出区别在于非零拷贝技术直接将数据传给网卡进行发送，少了一次拷贝到socket接口的操作。","link":"2024/09/26/Kafka%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"title":"AQS源码解析(二)","text":"在读本文之前，希望你已经阅读了AQS与JUC 概论 如下图所示，AQS类的继承关系：所有的锁均继承了 而AQS的结构如图所示： 123public ReentrantLock() { sync = new NonfairSync();} 由源码可得，默认构造的可重入锁是非公平锁。此外可以通过输入boolean值来构造公平锁： 123public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();} 公平锁与非公平锁 acquire 12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();} boolean tryAcquire(int acquires)：抢锁操作，返回是否成功。这里若抢锁失败则进入下一阶段，判断是否应该挂起线程。 boolean acquireQueued(final Node node, int arg)：判断当获取锁失败时是否挂起线程，若是则挂起线程。 Node addWaiter(Node) node：构建一个独占模式的节点，并维护好当前节点的前后指针 tryAcquire(arg) 默认入参为1，该方法的功能为抢锁操作，公平锁和非公平锁的抢锁操作是不同的。 公平锁-FairSync 这里不粘原码了，给出公平锁的流程图。 非公平锁-NonfairSync","link":"2024/06/16/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"Mysql知识点","text":"这一章将会讲解mysql相关的知识点。 基础知识 四种基本语句 DDL（Data Definition Languages）语句：即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，常用的语句关键字有：CREATE、ALTER、DROP、TRUNCATE、COMMENT。增删改表的结构。 DML（Data Manipulation Language）语句：即数据操纵语句，用来查询、添加、更新、删除等，常用的语句关键字有：SELECT、INSERT、UPDATE、DELETE、MERGE、CALL、EXPLAIN PLAN、LOCK TABLE，包括通用性的增删改查。增删改表的数据。 DCL（Data Control Language）语句：即数据控制语句，用于授权/撤销数据库及其字段的权限。常用的语句关键字有：GRANT、REVOKE。 TCL（Transaction Control Language）语句：事务控制语句，用于控制事务，常用的语句关键字有：COMMIT、ROLLBACK、SAVEPOINT、SET TRANSACTION。 数据结构 范式 第一范式：保证每列的原子性 第二范式：消除非主键对主键的部分依赖 在满足第一范式基础上（原子性），要求 非主键 都和 主键 完整相关， 而不能是依赖于主键的一部分 （主要针对联合主键而言）。 第三范式： 消除非主键对主键的传递依赖（保证每列都和主键直接相关） 在第二范式的基础上，令非主键列只依赖于主键，不依赖于其他非主键。 就是说表中的非主键字段和主键字段直接相关，不允许间接相关。 修正第三范式：bc范式 消除主键对非主键的部分依赖和传递依赖：前面都是非主属性对主属性之间的关系，主属性可能与非主属性也有关系，当3NF消除了主属性对码的部分函数依赖和传递函数依赖称为BCNF。 第四范式 非主属性不应该有多值，4NF是限制关系模式的属性间不允许有非平凡且非函数依赖的多值依赖。举例：用户联系方式表(用户id，固定电话，移动电话)，其中用户id是主键，这个满足了BCNF,但是一个用户有可能会有多个固定电话或者多个移动电话，那么这种设计就不合理，应该改为(用户id，联系方式类型，电话号码)。 第五范式 消除了4NF中的连接依赖。 数据类型 数值类型： TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT 浮点数类型FLOAT和DOUBLE 定点数类型DECIMAL 时间类型（常问区别）： 类型 大小(bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 ‘-838:59:59’/‘838:59:59’ HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 ‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’ YYYY-MM-DD hh:mm:ss 混合日期和时间值 TIMESTAMP 4 ‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC YYYY-MM-DD hh:mm:ss 混合日期和时间值，时间戳 TIMESTAMP 一般和时区有关，DATETIME与时区无关，推荐使用DATETIME 字符串类型：包括CHAR、VARCHAR、BLOB和TEXT Page 为了避免一条一条读取磁盘数据，InnoDB采取页的方式，作为磁盘和内存之间交互的基本单位。一个页的大小一般是16KB。 InnoDB为了不同的目的而设计了多种不同类型的页。比如：存放表空间头部信息的页、存放undo日志信息的页等等。我们把存放表中数据记录的页，称为索引页or数据页。 往数据页中存储数据（ 也叫 “记录”）,数据插入操作如下： 记录结构如下： 注意，如果数据格式运行出现null值，则会有一个null值列表值段，占用额外的存储空间。 记录在页中是按照主键值从小到大的顺序串联成为一个单向链表，因此查询也只能以头节点开始逐一向后查询。为了加快查询效率，因此出现了目录查询，即Page Directory。 页目录插满后数据结构如下： B+树： 可以参考博文B+树与B树的区别 为什么用B+数不用红黑树： 更少的查找次数 平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，检索的次数也就更多。 利用计算机预读特性 为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，因此速度会非常快。 操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点，并且可以利用预读特性，相邻的节点也能够被预先载入。使得数据库预读取更快 单个页之间是单向索引，不同页之间是双向索引。如果没有索引，就需要全表扫描 MyISAM 和 InnoDB的区别 InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。 MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。 MyISAM 不支持外键，而 InnoDB 支持。 MyISAM 不支持 MVCC，而 InnoDB 支持。 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。 MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。 InnoDB 的性能比 MyISAM 更强大。 索引 分类 主键索引：叶子节点里存储完整的数据（数据页），非叶子节点存储主键索引。 二级索引：叶子节点储存的数据只有主键，像唯一索引，普通索引，前缀索引等索引都属于二级索引。 聚簇索引：索引和数据结构放在一起，像主键索引就是聚簇索引。 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值，而无需回表查询，像如果在普通索引里构造了联合索引，通过而查询的字段正好是联合索引的值，则 无需回表查询，为覆盖缩影。 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并，如果查询的值不仅包含这些组合列，则还是要回表查询的。索引过程中满足最左前缀原则：指的是在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。 日志 redo日志 引言：假设在事务提交后突然发生了某个故障，导致内存中的数据都失效了，那么这个已经提交的事务在数据库中所做的更改也就丢失了。 方案1：在事务提交时，把该事务修改的所有页面都刷新到磁盘，刷新成功了才提示事务提交成功。 存在问题： 刷新一个完整的数据页太浪费了虽然我们只修改了一条记录，但是会将这条记录所在的页（16KB）都刷新到磁盘上，会造成大量磁盘I/O的浪费。 随机I/O刷新起来比较慢。 方案2：在事务提交时，只需要把修改的内容记录一下就好了。（redo log） redolog本质就是一种简单类型的日志，记录的是在某个页面的某个偏移量处修改了几个字节的值、具体修改后的内容 分类 简单日志类型：如果只是修改，仅需要简单日志类型 复杂日志类型： 如图可见，一条sql语句肯能对应几条redolog，若执行事务。若执行事务，为了保证事务的原子性，必须将redolog分组。 InnoDB认为，必须以组的形式来记录redo日志。在进行恢复时，针对某个组中的redo日志，要么把全部的日志都恢复，要么一条也不恢复。 undo日志 引言：事务是需要保证原子性的，也就是说，事务中的操作要么全部完成，要么什么也不做。当事务执行出错时，我们需要把数据还原回原来的样子，这个过程就叫做回滚（rollback）。 分类 insert操作： 名称 解释 end of record undoLog结束，下一条开始时在页面中的地址 undo type undoLog的类型，也就是TRX_UNDO_INSERT_REC undo no undoLog对应的编号，在一个事务中是从0开始递增的，只要事务没提交，每生成一条undo日志，那么该条日志的undo no就加1 table id undoLog对应的记录所在表的table_id start of record 上一条undoLog结束，本条开始时在页面中的地址 delete操作： 被删除的记录其实也会根据记录头信息中的next_record属性组成一个链表，只不过这个链表中的记录所占用的存储空间可以被重新利用，所以也称这个链表为垃圾链表。Page Header部分中有一个名为PAGE_FREE的属性，它指向由被删除记录组成的垃圾链表中的头节点。每删除一条记录，则该记录都会插入到垃圾链表的头节点处。（也就是说每个页都记录了当前页被删除的记录，若被重新利用则无法还原）。 update操作： 日志结构： 名称 解释 n_updated 表示本条UPDATE语句执行后将有几个列被更新。 被更新的列更新前信息&lt;pos, old_len, old_value&gt;列表 被更新列在记录中的位置、更新前该列占用的存储空间大小、更新前该列的真实值。 bin日志 undo log 和 redo log 这两个日志都是 Innodb 存储引擎日志，bin log属于server 层日志 redo log 和 bin log的区别 适用对象不同： binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用； redo log 是 Innodb 存储引擎实现的日志； 文件格式不同： binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下： STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致； ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已； MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式； redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新； 写入方式不同： binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。 redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。 用途不同： binlog 用于备份恢复、主从复制. redo log 用于掉电等故障恢复。 事务 四个特性 原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持久性（Durability） 事务id生成策略 生成策略如下： 内存中维护一个全局变量，每当需要为某个事务分配事务id时，就会把该变量值当作事务id分配给该事务，并且自增1。 每当这个变量的值为256的倍数时，就会将值刷新到系统表空间中页号为5的页面中一个名为Max Trx ID的属性中（占用8个字节）。 当系统下一次启动时，会将Max Trx ID的值加载到到内存中，并加上256之后赋值给前面提到的全局变量（因为上次关机时，该全局变量的值可能大于磁盘页面中的Max Trx ID属性值）。 事物的状态 三个事务并发一致性问题 脏读：一个事务读取到了另一个未提交事务修改过的数据 不可重复读：一个事务修改了另一个未提交事务读取的数据就意味着发生了不可重复读现象，或者叫模糊读FuzzyRead 幻读：如果一个事务先根据某些搜索条件（select … where vip=‘是’）查询了一些记录，但是在该事务并未提交时，另一个事务写入了一些符合上面搜索条件的记录。导致下一次用该查询语句发生出错，说明发生了幻读现象。 四个隔离级别 隔离级别 脏读 不可重复读 幻读 读未提交 Y Y Y 读已提交 N Y Y 可重复读 N N Y 串行化 N N N MVCC MVCC (Multi-Version Concurrency Control)多版本并发控制，利用记录的版本链和ReadView，来控制并发事务访问相同记录时的行为。 ReadView 一致性视图，用来判断版本链中的哪个版本是当前事务可见的。 版本链 在每次更新该记录后，都会将旧值放到一条undo日志中。随着更新次数的增多，所有的版本都会被roll_pointer属性连接成一条链表，这个链表就称之为版本链。 ReadView ReadView也叫一致性视图，用来判断版本链中的哪个版本是当前事务可见的。 名称 解释 m_ids 在生成ReadView时，当前系统中活跃的读写事务的事务id列表。 min_trx_id 在生成ReadView时，当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。 max_trx_id 在生成ReadView时，系统应该分配给下一个事务的事务id值。 creator_trx_id 生成该ReadView的事务的事务id。 判断事物是否可见 if(RC.trx_id == RV.creator_trx_id) 则表明当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。 if(RC.trx_id &lt; RV.min_trx_id) 则表明生成该版本的事务在当前事务生成ReadView之前已经提交了，所以该版本可以被当前事务访问。 if(RC.trx_id &gt;= RV.max_trx_id) 则表明生成该版本的事务在当前事务生成ReadView之后才开启，所以该版本不可以被当前事务访问。 if(RC.trx_id in RV.m_ids) 说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 if(RC.trx_id not in RV.m_ids) 说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问（m_ids为空集合）。 if(某个版本的数据对当前事务不可见) 那就顺着版本链找到下一个版本的数据，并继续执行上面的步骤来判断记录的可见性，以此类推，直到版本链中的最后一个版本。 总结一下：先看是否是同一个事物，再与min，max比较判断是否可显示。此时剩下的在min，max中间，最后看m_ids看是否可显示。 MVCC生成时机 READ COMMITTED——在一个事务中，每次读取数据前都生成一个ReadView。 REPEATABLE READ——在一个事务中，只在第一次读取数据时生成一个ReadView。 锁 引言：由于任何一种隔离级别都不允许脏写（写-写）的现象发生，所以，当多个未提交事务相继对一条记录进行改动的时候，就需要让它们排队执行。 概念：这个排队的过程其实是通过为该记录加锁来实现的。这个锁本质上是一个内存中的结构。 有两种方式实现 读-MVCC，写-锁（效率高） 读写-锁（在特定的场景，银行业务，需要读取最新数据和数据准确性，对执行时间并无苛刻要求，需要都加锁） 行级锁 共享锁 / S锁（Shared Lock） 在事务要读取一条记录时，需要先获取该记录的S锁。 1select ... lock in share mode; 独占锁 / 排它锁 / X锁（Exclusive Lock） 在事务要修改一条记录时，需要先获取该记录的X锁。 1select ... for update; 仅共享锁之间兼容。 表级锁 表级共享锁（S锁）其他事务可以继续获得该表/该表中的某些记录的S锁。其他事务不可以继续获得该表/该表中的某些记录的X锁。 表级独占锁（X锁）其他事务不可以继续获得该表/该表中的某些记录的X锁或S锁。 意向共享锁（IS锁）当事务准备在某条记录上加S锁时，首先需要在表级别加一个IS锁。 意向独占锁（IX锁）当事务准备在某条记录上加X锁时，首先需要在表级别加一个IX锁。 S锁和IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，以避免用遍历的方式来查看表中有没有上锁的记录；也就是说，IS锁和IX锁之间或者与自身都是彼此兼容的 InnoDB表级锁 LOCK_REC_NOT_GAP 被称为记录锁，也就是仅仅负责把1条记录锁上的锁。 LOCK_GAP 被称为gap锁，锁住了指定记录前面的间隙，防止其间插入新记录。gap锁的提出仅仅是为了防止插入幻象记录（即：幻读现象）而提出的。 LOCK_ORDINARY 被称为next-key锁，本质就是一个 记录锁 + gap锁 的合体。它既能保护该条记录，又能阻止别的事务将新纪录插入到被保护记录前面的间隙中。","link":"2024/09/26/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"Redis概述","text":"本篇文章会讲述Redis的基本知识点。 Redis基础数据类型及其编码 概述：Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 特性（为啥比较快）： 基于内存 基于Reactor模式开发了一套高效的时间处理器，主是单线程事件循环和 IO 多路复用。 Reactor模式：每当有一个 Event 输入到 Server端时，Service Handler 会将其转发（dispatch）相对应的handler进行处理。（类似于将消息放到了一个队列中，通过异步线程池对其进行消费） Redis内置了多种优化过后的数据类型/结构实现，性能非常高。 Redis基础数据类型要牢记： string list set zset hash 以上是Redis的几种数据结结构。Redis底层实现上面这几种数据类型是靠以下的编码实现的，例如关于string，编码方式给出了如何将这种数据类型转化成01bit串。 encoding常量 底层数据结构 INT long类型整数 EMBSTR embstr编码的简单动态字符串 RAW 简单动态字符串 HT 字典 LINKEDLIST 双向链表 ZIPLIST 压缩列表 INTSET 整数集合 SKIPLIST 跳表和字典 Redis数据结构 现在看一下对象类型和对应的底层编码： String类型 int编码 说白了，就是将数字字符串用Long类型来表示。超过这个范围就使用其他编码 embstr编码 如果value值的长度如果小于40，则使用embstr，它可以保存数字类型和字符类型的值。embstr编码是专门用于保存短字符串的一种优化编码方式（可以从图中看出在embstr里申请的是一块连续空间）。 这种连续分配的空间不利于字符串的修改。应此embstr是只读的。如果我们对其进行修改，其实是先转换成raw，再执行修改命令。所以，修改后embstr就会变为raw编码的字符串对象了。 raw编码 当value值的长度如果大于等于40时，则使用raw编码。 如果将原本保存的整数转换为字符串，那么字符串对象的编码也将从int变为raw。 list类型 ziplist编码 linkedlist编码 set类型 intset编码 hashtable编码 zset类型 像zset类型数据也有压缩列表的实现方式，除此之外也可以用跳表作为底层实现，一个zset同时包含一个字典dict和一个跳跃表zskiplist。 概述：跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来。 条表的优点： 内存非密集型，在更改节点方面比较容易。 在做范围查找的时候，跳表比平衡树操作要简单。 从算法实现难度上来比较，跳表比平衡树要简单得多。 由于zset经常需要排序，在插入节点时跳表也更加适合遍历查找列表元素。 hash类型 同理可以使用压缩列表和hashtable编码的实现方式 Redis的持久化 RDB 概述：RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，对应文件为dump.rdb，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。 分为手工执行RDB和定期执行RDB 手工执行两个命令SAVE和BGSAVE: SAVE命令：会阻塞进程。 BGSAVE命令：会fork一个子进程来生成RDB文件 只要Redis启动时检测到RDB文件的存在，那么就会自动载入RDB文件。加载过程中，会一直处于阻塞状态，直到加载完毕为止。由于AOF文件的更新频率一般比RDB文件的更新频率高，所以，如果服务期开启了AOF持久化功能，那么就优先加载AOF文件。 AOF 概述：Redis的持久化方式之一RDB是通过保存数据库中的键值对来记录数据库的状态。而另一种持久化方式 AOF 则是通过保存Redis服务器所执行的写命令来记录数据库状态。 流程：AOF的持久化分为三步：命令追加 ——&gt; 文件写入 ——&gt; 文件同步，如果打开AOF后，每次执行完一个写命令之后，都会把写命令以请求协议格式保存到 aof_buf缓冲区 的末尾。 AOF同步：将AOF缓冲区的内容加载进磁盘中 AOF重写流程： 简单用人话概括一下： 执行重写，开启子进程开始重写到AOF缓冲区，再此期间的AOF命令也会写到重写缓冲区。（写时复制技术，RDB,AOF都有这种技术） 重写结束后，阻塞进程，用重写缓冲区的内容去覆盖AOF缓冲区（新文件覆盖就文件）。 覆盖结束后开始继续向AOF缓冲区内写内容。 混合持久化 概述： RDB优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。 AOF优点是丢失数据少，但是数据恢复不快。 混合持久化工作在 AOF 日志重写过程，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。 特殊数据类型 先提一嘴，以后有用到再补充细节。 geospatial地理位置 可以用于基于地理位置的业务场景。 hyperloglog预估集合的基数 非精准性的统计计数 bitmap位图 可以利用bitmap指定其二进制位是0或1，来实现类似“是”or“否”的相关操作。它的特点也是占用内存空间特别的小。 Redis主从复制 Redis缓存失效 缓冲穿透 概述：当用户查询数据时，发现Redis中不存在，也就是所谓的缓存没有命中，于是这个数据请求就会打到数据库中。 解决方法： 在redis里维护一个空对象（如果数据库里查询不到） 添加布隆过滤器 缓冲击穿 概述：热点key被高并发查询，在热key过期时，对数据库造成巨大的压力。 解决方案： 设置热点key永不过期 加上互斥锁，只允许一个线程去查询数据库。 缓冲雪崩 概述：缓存集中过期，或者redis宕机 解决方案： 针对Redis宕机这一点：配置Redis集群 熔断限流：通过加锁或队列来控制读写数据库的线程数量 针对集中过期：数据预热或者分散数据过期时间 布隆过滤器 概述： bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。 如图：bloom的重点在于容器的大小和散列函数 缓存淘汰策略 不淘汰：缓存写满直接返回错误消息。 过期数据： ttl:最早过期的先淘汰 lru:淘汰最近最少使用数据 lfu:淘汰使用频次最少数据 全部数据： 随机淘汰 lru lfu 缓存读写策略 Cache Aside Pattern（旁路缓存模式） Cache Aside Pattern中服务端需要同时维系db和cache，并且是以 db的结果为准。 先更新 db 然后直接删除 cache 。 为什么先删除后更新不行： 请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 数据更新 -&gt; 请求 2 往缓冲中写入数据。 Read/Write Through Pattern（读写穿透） 写（Write Through）： 先查cache，cache中不存在，直接更新db。 cache中存在，则先更新cache，然后cache服务自己更新db。 读(Read Through)： 从 cache 中读取数据，读取到就直接返回。 读取不到的话，先从 db 加载，写入到 cache 后返回响应。 Write Behind Pattern（异步缓存写入） Read/Write Through是同步更新cache和db，而Write Behind Pattern则是只更新缓存，不直接更新db，而是改为异步批量的方式来更新db。 Redission 概述： Redisson 是架设在 Redis 基础上的一个 Java驻内存数据网格框架, 充分利用 Redis 键值数据库提供的一系列优势, 基于 Java 使用工具包中常用接口, 为使用者提供了 一系列具有分布式特性的常用工具类。 具体阐述其原理，首先得分析其redis的分布式锁 基于redis的分布式锁 使用Redis的setnx命令进行加锁，当该指令返回1时，说明成功获得锁。 但是这种锁存在两个问题： 超时解锁导致并发：：用户A先获取锁，还未执行完业务代码，此时已经过了超时时间，锁被释放。用户B获取到锁，此时用户A和用户B并发执行业务数据。 锁误删除:：用户A执行完业务代码后，执行释放锁操作，而此时用户A已经被超时释放，锁被用户B持有，此时释放锁，就把用户B的锁误删了。 不能支持redis集群。 而redisson实现了 防死锁 防误删 可重入 自动续期 主要的实现方式有三步： uuid+线程id作为key防止误删除 看门狗机制防止超时并发 redLock支持redis集群 RedLock算法 原理：Redlock算法首先获取当前时间戳T1，然后在N个Redis节点上尝试获取锁，并记录获取锁的节点数M和最小的锁超时时间min_expire_time。如果获取锁的时间cost_time小于锁的超时时间，并且M大于等于Q，则认为锁获取成功，返回锁的value值和锁的超时时间；否则依次在获取锁的节点上释放锁。 看门狗机制 Redisson针对业务还未处理完毕，锁就提前过期这个问题的解决办法：提供一个守护线程，定时检查锁状态。如果锁快要过期了，客户端还占有锁，那么就自动给锁续期，延长锁的过期时间。","link":"2024/09/23/Redis%E6%A6%82%E8%BF%B0/"},{"title":"git指南","text":"git作为最常用的分布式版本控制工具，是企业合作开发比不可少的工具。当你发布的代码出现问题后，大多都是靠git来解决的。目前市面上git的使用方法有很多，本文会总结大部分工作中常用的git命令(对于一些少见的复杂场景下的git应用，这个到时候再查也没问题)，总而言之，如果你的代码出了岔子抑或着捅了什么篓子，git绝对是帮你兜底的亲爸爸般的存在。笔者纯萌新入职，总结一下工作几天的git学习情况 基本原理 首先聊一下git的基本原理： 如图：git分为四个区域 Workspace： 工作区，就是平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器 我们通常开发工作方式，是从主分支创建一条属于自己的分支，在这个分支上完成自己要实现的功能。再将自己的分支提交给远程仓库实现代码合作。而企业开发中，远程仓库是通常分为多种分支，每个分支对应一种环境，例如 测试环境：所有人员提交的分支都会先合并到这个分支中，在这个分支上自动构建项目，来测试功能是否正常运行，测试环境是给开发人员用，用于调试代码，因此包含了很多正在开发的代码修改。 预发布环境：预发布环境是给产品人员用的，如果产品觉得没有问题了，就可以准备正式上线到生产环境。 生产环境：到这一步就是给广大的客户使用的，到这一步，代码合并正式完成，此时的分支通常就是我们所谓的master分支（两条分支内容一样但通常是分开的）。 通常企业会利用工具自动在这些分支上构建项目，程序员要做的就是把自己的分支合并到这些分支上。 一次基本的拉去分支的流程 相信很多同学都用过githubclone代码，这里就不赘述了。通常情况下，我们在企业开发过程中，如果有分配到相关的需求，需要我们自己来在远程创建属于自己的分支（这个过程通常有用相关系统一键式创建，不用自己敲命令）。记得在主分支上执行： 1git pull 拉取最新代码（自己的远程分支），通过 1git checkout [分支名] 来切换到自己的分支并开发最后 12git add # 将文件放入缓存区，我们可以通过 git status 查看是否有未提交的文件git commit -m &quot;hello git&quot; 实现提交，此时用git log查看可以看到字节提交的记录。也许会用同学说，现在使用idea基可以通过图形化工具来解决，跟不需要了解这些命令，作者本人在刚入行的时候也甚是喜欢idea图形化工具，但是idea的图形化工具除了执行git命令外还增加了一些代码审查、提示等其他功能，个人认为如果做为页面展示工具十分不错，但是如果是涉及核心等如merge,reset,cherypick等操作，还是用命令行工具比较方便。 解冲突 马上就来到开发中最常见的情形–发生冲突。冲突一般发生在git merge合并时，当你上传代码到远程并试图合并到测试分支上时，若存在另一个小伙伴，在你改动代码到同一处地方进行修改，且已经合到了测试分支上。由于你们的分支都是从master分支拉取下来的，你们在开发代码时彼此看不到互相的改动，当代码合并时就会发生冲突。 既然知道了冲突是怎么发生的，那么解冲突的位置也就一目了然了。冲突时发生在我们试图将测试分支合并到测试分支上时发生的，那么解决冲突就是在测试分支上解决。 你所创建的开发分支是干净的分支，与master分支的改动仅包含你业务需求的改动。 一般在远程解冲突的过程，企业会通过一些技术手段将发生冲突的地方组装另外的一条冲突分支（分支内容包含你的分支和所有的测试分支），你可以拉取这条冲突分支在本地解完冲突后再将这条分支推送回去，之后就可以删除这条分支了。 我们来看看冲突发生的一般形式： 1234567// &lt;---&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;// 主分支上的修改==========// 被合并的分支上的修改&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;// &lt;---&gt; 这个时候你调整代码，把‘&lt;&lt;’,‘==’,‘&gt;&gt;’删除，使代码能够正常运行，就能解决冲突了。 回退版本 在开发过程中,经常会遇到我们难以处理的bug或异常，这个时候就需要回退版本了，我们可以通过 1git reset --hard [版本号] 来回退版本，版本号可以通过git reflog来查看，但是注意，这里是硬回退，一旦回退后，最近的修改就不可见了，如果希望软回退，那么就需要使用命令git reset --soft实现一个软回退，在这种回退使得你仍然能够查看最近的提交。 隐藏修改 在日常开发中，我们可能需要同时处理多个需求，因此一个项目中可能存在多个分支，故而我们需要在多个分支间切换。当为们开发一个分支开发到一半时，常常面临着需要切换到另一条分支去工作的情况，或者说你在错的分支上开发了，需要将这份修改转移到其他地方，而这些修改还未提交。当然你也可以选择先提交的方式再转移分支，但是日常开发中你需要时刻主要你修改了哪些地方，因此不建议直接提交。 我们可以通过 1git stash 来将当前分支的内容隐藏，此时所有的改动都会被暂时存进缓存区。通过git status可以查看我们的分支是干净的–没有修改，在这个时候我们切换分支就是安全的。 1git stash list 我们可以查看暂存的分支，以及是在哪条分支缓存的修改，而 1234567# 还原分支git stash apply # 删除stash缓存git stash drop# 等价于 apply+dropgit stash pop 能将修改提交，甚至提交到其他分支。这样既是我们不小心在错误的分支上开发，也可以将修改转移到正确的分支。","link":"2024/06/29/git%E6%8C%87%E5%8D%97/"},{"title":"ThreadLocal源码解析","text":"最近在整理ThreadLocal，打算把这方面的内容好好理一理。 概述 ThreadLocal 是一个线程的本地变量，这个变量是线程独有，且不能与其他线程共享的。 我们都知道线程是处理器调度的基本单位，而进程是资源调度的基本单位。在高并发情况下如果线程频繁去访问内存资源极容易造成线程冲突，而且有些线程工作需要线程去维护一个临时变量，ThreadLocal就是每个线程都有一个资源副本，是不需要加锁的。 可以这样去理解： 锁是通过时间换空间的做法。 ThreadLocal是通过空间换时间的做法 源码解析 set方法 123456789101112131415/** * 若map为空，则创建ThreadLocalMap */public void set(T value) { Thread t = Thread.currentThread(); //获取当前前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { //调用ThreadLocalMap的set方法 map.set(this, value); } else { createMap(t, value); }} 我们可以看到ThreadLocalMap对象只有在第一次调用时才会通过createMap方法初始化。 我们先看一下createMap方法，ThreadLocalMap的set方法稍后再看。createMap是ThreadLocal里的方法,他需要传入当前线程和新值 123void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);} 我们可以看到，这里new出来的ThreadLocalMap赋值给Thread对象里的threadLocals变量，从这里可以看出ThreadLocalMap是当前线程Thread的一个全局变量。同时它在初始化ThreadLocalMap时还传入了一个this指针，这个指针就是ThreadLocal对象。 接下来我们看看ThreadLocalMap的初始化函数 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) { //INITIAL_CAPACITY = 16 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);} 我们可以看到这里ThreadLocalMap初始化的基本流程： 初始化ThreadLocalMap里的Entry类型的数组变量table 计算firstKey的hashCode，用坐数组下标 这里我们注意firstKey时刻指代的是ThreadLocal对象,计算下标时是通过hashCode和的(INITIAL_CAPACITY - 1)与运算 给table[i]赋值 初始化size 设置table阈值 我们再来看看ThreadLocalMap的set(this,value)方法 123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) { // 这里的tab是table的一个弱引用 Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); /** * 这里判读e!=null就很灵性了，说明循环退出条件是一直往数组下一个index查找，直到下一个index对应的元素为null；（这个不就是我们的开放地址法） * * 这里遍历的逻辑是，先通过hash找到数组下标，然后寻找相等的ThreadLocal对象，找不到就往下一个index找。 */ for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?&gt; k = e.get(); //找到了相同key的ThreadLocal对象，然后更新value值，退出； if (k == key) { e.value = value; return; } //找到了数组中的一个元素Entry，但是key=null，说明虚引用是可被GC回收的状态，赋值完后，整理内存后退出； if (k == null) { replaceStaleEntry(key, value, i); return; } } //此时tab[i]值为null 可以赋值 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) /** 对table数组和元素进行整理操作，超过阈值rehash*/ rehash();} 总结一下上述的关系，当我梦创建一个ThreadLocal对象并调用set方法时，这个对象才会去查找当前线程是否包含ThreadLocalMap对象（变量threadLocals,可以理解为Threadlocal对象到value到映射）,没有则创建。在ThreadLocalMap对象里包含了一个Entry[]数组，在数组上面查找返回值。（底层是利用数组构建hash表，解决冲突使用开放地址法。 nextIndex和prevIndex 接下来，我们再细看一下其中涉及到的方法，首先是移动地址i的方法 1234567private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0);}private static int prevIndex(int i, int len) { return ((i - 1 &gt;= 0) ? i - 1 : len - 1);} 分析代码可得，当i超过len时，会访问下标0,也就是说这是循环查找（开饭地址法嘛）。 replaceStaleEntry 当这个已存在的Entry元素key==null的时候，逻辑上就走到——replaceStaleEntry(key, value, i)，该方法是用来替换“陈旧的”Entry的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; /** * 从过期key的位置用preIndex向前查找 * 并标记在staleSlot前连续的Entry中第一个过期的key为stolToExpunge */ for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; /** * 从过期key的位置用newIndex向后查找 */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { /** * 从staleSlot后的位置找到一个与key值相同的Entry * 根据开放地址法可知，我们应该清除掉后面的(key,.),把新值到前面的key中 */ e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // 若相等，说明在staleSlot前面找不到失效的key,直接清理i处的slot，退出即可 if (slotToExpunge == staleSlot) slotToExpunge = i; //这里优先清理掉是staleSlot前的过期key cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } /** * 从staleSlot后的位置找到一个与key过期的Entry 且在staleSlot前没有找到一个过期key,才会赋值slotToExpunge 为 i * 到这我们可以发现若要slotToExpunge = i,必须有slotToExpunge == staleSlot * 从这里可以看出优先清理staleSlot位置前过期的key */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; } // 上面循环结束说明后面没有相同的key值需要清理，可直接在staleSlot上赋值 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) //此时说明找到了一个待清除掉slotToExpunge位置，且优先清理靠前的位置。 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);} 在分析上述代码后，我们可知replaceStaleEntry总共做了两件事情： 在过期的key的位置附上新值，（但是在赋值前一定会向后检测是否存在相同key的值，若有一定要清楚掉） 去找在staleSlot里连续的Entry里第一个过期的Endtry的位置，并把它传入expungeStaleEntry（注意这个位置肯定是我们填完新（key,value）后的位置）。 这里给出一张replaceStaleEntry等图示，注意理解连续的Entry的概念 这里有个问题，为啥一定要找连续的Entry里第一个过期的Endtry的位置，我们可以看看expungeStaleEntry方法和cleanSomeSlots方法 expungeStaleEntry 1234567891011121314151617181920212223242526272829303132333435363738private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; /** 清除staleSlot槽位对应的对象引用 */ tab[staleSlot].value = null; tab[staleSlot] = null; size--; /** 数组中元素总数减1 */ Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); /** 如果key==null，则清除掉对应槽位的元素，并且size减1 */ if (k == null) { e.value = null; tab[i] = null; size--; } else { /** * 这里主要的作用是由于采用了开放地址法，所以删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，可以简单理解 * 就是让后面的元素往前面移动。 */ int h = k.threadLocalHashCode &amp; (len - 1); // 应该坐：h 但是我坐在了：i if (h != i) { // 表示k现在所在的位置i并不是它应该在的位置h上。而是由于开放地址法，放到了别的位置上 tab[i] = null; //找到h所在的位置，若tab[h] == null,说明h在前面被清除的位置，直接存值 while (tab[h] != null) { // 说明hash是有冲突的，那么往后找空的位置 h = nextIndex(h, len); } tab[h] = e; } } } //此时在staleSlot和i之间已经没有过期的key,i后面的都是null return i;} 现在我们可以理解为什么要去找最连续entry里第一个过期key了： 根据开放地址法，当我们扫到null时会停止扫描，而当我们扫到过期key时会清理掉该key，为了防止后面的key扫描不到，因此我们应该整理从连续entry里第一个过期key开始整理，遇到一个过期key便删除，同时重新计算后面的每个元素并排序。 cleanSomeSlots 1234567891011121314151617// 初始状态n=lengthprivate boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) { //遇到过期键则删除 n = len; removed = true; i = expungeStaleEntry(i); // 从位置i开始清除Stale元素，并在这个过程中&quot;整理&quot;元素到趋近正确的位置，直到遍历到null的Slot } } while ( (n &gt;&gt;&gt;= 1) != 0); /** n&gt;&gt;&gt;=1相当于n=n/2*/ // i 连续移动log2(len)次，若再每遇到过期键则退出 return removed;} 现在知道为什么这个方法称为cleanSomeSlots,该方法只能保证大部分的陈旧键被删除 可以理解为是对于提升插入速度和table数组内“陈旧”Entry整理耗时的一种平衡处理方案 rehash 12345678private void rehash() { expungeStaleEntries(); /** 清除表中的所有陈旧条目 */ // Use lower threshold for doubling to avoid hysteresis（使用较低的加倍阈值以避免滞后） if (size &gt;= threshold - threshold / 4) { resize(); /** 扩容操作 */ }} 超过table的3/4则扩容。 expungeStaleEntries 遍历table数组里的Entry，调用expungeStaleEntry方法，这里就不粘源码了。 resize 1234567891011121314151617181920212223242526272829303132private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; /** 将原数组大小扩容2倍 */ int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; // Help the GC } else { /**计算旧的Entry在新的table数组中的位置h */ int h = k.threadLocalHashCode &amp; (newLen - 1); /** * 如果位置h已经被别的Entry占据了，那么就向后查找空位，直到找到为止 */ while (newTab[h] != null) { h = nextIndex(h, newLen); } newTab[h] = e; count++; } } } /** 因为使用了新的数组，所以设置一下新的table数组的阈值 */ setThreshold(newLen); size = count; table = newTab;} 简单来说就是创建新数组，遍历旧数组的每一个值，计算新的hashCode，赋值。 get ThreadLocal中get方法就相对简单很多。我们对照源码进行依次解读 12345678910111213public T get() { Thread t = Thread.currentThread();// 获取当前线程 ThreadLocalMap map = getMap(t);//获取ThreadLocalMap对象 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue();} 这里是相似的业务逻辑，若果存在map，则查找对应的entry并返回结果。 但是如果不存在ThreadLocalMap，setInitialValue会创建一个ThreadLocalMap,并返回一个默认值，默认值为null（这里不具体显示代码了）。 我们看一下ThreadLocalMap类下的getEntry方法： 12345678private Entry getEntry(ThreadLocal&lt;?&gt; key) { int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);} 属于基本的hash数组查找法，但是要注意如果查找的entry为空或者e.get() != key时处理方法： 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) {//根据开放地址查找法，若key!=null向后遍历 ThreadLocal&lt;?&gt; k = e.get(); if (k == key)//查找到相同元素就返回 return e; if (k == null)//key为null说明这是一个过期的key expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null;//若e==null则直接返回null} 内存溢出 通过上面的分析，我们知道 expungeStaleEntry() 方法是帮助垃圾回收的。 get 和set 方法都可能触发清理方法 expungeStaleEntry() 正常情况下，不会存在溢出，但是 如果我们没有调用get和set的时候就会可能面临着内存溢出。养成好习惯不再使用的时候调用remove()，加快垃圾回收，避免内存溢出。退一步说，就算我们没有调用get和set和remove方法，线程结束的时候，也就没有强引用再指向ThreadLocal中的ThreadLocalMap了，这样ThreadLocalMap和里面的元素也会被回收掉。但是有一种危险是，如果线程是线程池的，在线程执行完代码的时候并没有结束，只是归还给线程池，这个时候ThreadLocalMap和里面的元素是不会回收掉的。 最近把java并发编程的知识重新整理了一下，有一部分文档写在飞书上了。内容和图片来自于互联网，有侵删。 这是以前做的一些笔记：Java并发编程","link":"2024/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"2024/05/27/hello-world/"},{"title":"hexo-Icarus页面优化","text":"记录一次页面调整，简单介绍一下，本人前端小白，style语法基本不懂，关于页面大小问题查询了很多资料。最后调整将大小调整到一个比较满意的程度 页面宽度调整 众所周之hexo初始设置中，内容展示页面过小，两边距离过大，因此文章内容看起来及其不自然。 经过我查阅以下及相关文档： Icarus主题美化 Icarus widget 宽度如何修改？ Hexo博客icarus主题定制篇 Hexo博客主题之Icarus的设置与美化 风月的博客（非常全） 内容总算是明白怎样设置了【痛哭】 有不少大佬改成首页内容为三栏，文章浏览为两栏的模式，但本文仅针对两栏的改写。 调整文章内容页面宽度 步骤一 修改themes/icarus/include/style/base.styl文件为： 123\\\\第26行- $gap ?= 32px+ $gap ?= 32px 这段代码可以减小两边的空白 步骤二 修改themes/icarus/layout/layout.jsx文件为 123\\\\第29行- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 注意是把第三个8改成9，这段代码代表当采用两栏格式时，会扩大文章内容页面，但是修改过后左右两边会不对称，也就是github上讨论的问题 步骤三 修改themes/icarus/layout/common/widgets.jsx文件为 1234case 2:\\\\第44行- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; 这段代码代表当文章为两栏时，使得widget宽度为3，注意必须使得文章内容长度+widget宽度为12，否则格式会乱 标题调整 我在themes/icarus/include/style/article.styl文件中设置了标题的大小和颜色，具体看风月的博客。 雪花效果 雪花效果 试了试，好像没啥效果，以后再总结 高级用途 强推：hexo写文在必备 hexo入门写作","link":"2024/06/15/hexo-Icarus%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"},{"title":"YHJ23","text":"今天读一篇发在FOCS上的论文 Attribute-Based Encryption for Circuits of Unbounded Depth from Lattices 文章很长，先从方法论下手，浅读一下方法，细节部分日后再补充。 研究背景 目前主流的基于格的ABE芳芳如GVW13,BGG+14等，所能够容纳的电路深度都是有限的，同时它们的组件（主公钥，主私钥，和密文）在最大电路中具有多项式大小深度。（这句话读起来有些费解，我的理解是，例如深度为2，则有22=42^2=422=4个辅助电路加密的公钥或者说对应的密文，而计算密钥时计算深度也会达到2）。为了消除基于格的ABE对电路深度的依赖，作者提出了一种新的方案 研究成果 作者提出构造一个1-key ABE所用到的密码学原语有 laconic function evaluation (LFE) 1-key functional encryption (FE) reusable garbling schemes. 作者构造了一系列上述原语的方案，同时还基于evasive circular LWE assumption（一种加强的evasive LWE assumption）实现了一个比较成熟的ABE方案。 预备知识 再了解整个方案之前，我们先看一下所用到的组件 Circular Evasive LWE 我们先从evasive LWE开始，如下为evasive LWE假设的内容，为了方便理解后面的Circular Evasive LWE,B,A‾′B,\\overline{A}^{\\prime}B,A′采用了相同的分布，两个变量在这里是一样的。 if (1): B,A‾′,P,r⊤B⏟,r⊤⏟A‾′,r⊤P⏟\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{B}}, \\underbrace{\\mathbf{r}^{\\top}} \\overline{\\mathbf{A}}^{\\prime}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{P}}B,A′,P,r⊤B​,r⊤​A′,r⊤P​, aux ≈\\approx≈ (2): B,A‾′,P,$,$,$\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\$B,A′,P,$,$,$, aux, then (3): B,A‾′,P,r⊤B,r⊤A‾′,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\mathbf{r}^{\\top} \\mathbf{B}, \\mathbf{r}^{\\top} \\overline{\\mathbf{A}}^{\\prime}, \\quad \\mathbf{K}B,A′,P,r⊤B,r⊤A′,K, aux ≈\\approx≈ (4): B,A‾′,P,$,$,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\mathbf{K}B,A′,P,$,$,K, aux. 其中B←$Zqn×m\\mathbf{B}\\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_q^{n \\times m}B←$Zqn×m​, m=Θ(nlog⁡p)m=\\Theta(n \\log p)m=Θ(nlogp), K←$B−1(P)\\mathbf{K} \\stackrel{\\$}{\\leftarrow} \\mathbf{B}^{-1}(\\mathbf{P})K←$B−1(P), K\\mathbf{K}K是一个低范数矩阵满足BK=P\\mathbf{B K}=\\mathbf{P}BK=P。我们可以这么去理解这个假设，只要不给敌手获悉BK=P\\mathbf{B K}=\\mathbf{P}BK=P，给定X\\mathbf{X}X,r⊤B+e\\mathbf{r}^{\\top} \\mathbf{B}+er⊤B+e,r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e,不论X\\mathbf{X}X为何种分布，r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e均为伪随机性的。 circular evasive LWE假设如下， if (1), Afhe ,S,Acirc ,s⊤(Acirc −S⊗G)≈(2),$,$,Acirc ,$, then (3), Afhe ,S,Acirr ,s⊤(Acirc −S⊗G)≈ (4), $,$,Acirc , \\begin{aligned} &amp;\\text { if (1), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {circ }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx(2), \\$, \\$, \\mathbf{A}_{\\text {circ }}, \\quad \\$ \\text {, } \\\\ &amp; \\text { then (3), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {cirr }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx \\text { (4), } \\$, \\$, \\mathbf{A}_{\\text {circ }} \\text {, } \\\\ \\end{aligned} ​ if (1), Afhe ​,S,Acirc ​,s⊤(Acirc ​−S⊗G)≈(2),$,$,Acirc ​,$, then (3), Afhe ​,S,Acirr ​,s⊤(Acirc ​−S⊗G)≈ (4), $,$,Acirc ​, ​ 这里暂时认为这个假设是对的，不看这方面的证明。 模数法缩小噪声 我们有如下方法缩减噪声，令MMM为qqq的因子，CCC为一个低深度的电路，如下等式成立： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌋=(s⊤AC, small −C(x)s⊤Gsmall +esmall ⊤) mod qM\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rfloor \\\\ = &amp; \\left(\\mathbf{s}^{\\top} \\mathbf{A}_{C, \\text { small }}-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}+\\mathbf{e}_{\\text {small }}^{\\top}\\right) \\bmod \\frac{q}{M} \\end{aligned}=​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎥⎥⎥​(s⊤AC, small ​−C(x)s⊤Gsmall ​+esmall ⊤​)modMq​​ 经推理可得： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM]=(⌊(s⊤AC+elarge ⊤) mod qM⌉−C(x)s⊤Gsmall ) mod qM=Φ(⌊s⊤AC mod qM⌉−C(x)s⊤Gsmall ) mod qM.\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right] \\\\ = &amp; \\left(\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top} \\mathbf{A}_C+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} \\\\ \\stackrel{\\Phi}{=} &amp; \\left(\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} .\\end{aligned}==Φ​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎤​⎝⎛​⎣⎢⎢⎢​M(s⊤AC​+elarge ⊤​)modq​⎥⎥⎥⎤​−C(x)s⊤Gsmall ​⎠⎞​modMq​(⌊Ms⊤AC​modq​⌉−C(x)s⊤Gsmall ​)modMq​.​ 为了让第一个等式成立，M为2的指数次放，这样可以使得M/GM/GM/G为整数,让M/GM/GM/G能被规约为GsmallG_{small}Gsmall​。 注意第二个等式是概率成立的，即，当elargee_{large}elarge​没有足够大时，可以使得四舍五入后的值相同。通过规约后再乘以M,可以舍得原式变回模M. M⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌉=(M⌊s⊤AC mod qM⌉−C(x)s⊤⋅MGsmall ) mod q\\begin{aligned} &amp; M\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil \\\\ = &amp; \\left(M\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\cdot M \\mathbf{G}_{\\text {small }}\\right) \\bmod q\\end{aligned}=​M⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎥⎥⎥⎤​(M⌊Ms⊤AC​modq​⌉−C(x)s⊤⋅MGsmall ​)modq​ 利用四舍五入可以使得恢复该数恢复到模q。但是这里有个坑，MGsmallMG_{small}MGsmall​只包含较大的2的幂次方，所以还需要设计一种可以恢复G的方法。（这里细节比较多，暂时不讲）解决的大致思路就是把G分为两部分，一部分是可以通过⌊XM⌉M\\left \\lfloor \\frac{X}{M} \\right \\rceil M⌊MX​⌉M复原的部分，和不能通过其复原的部分。 最后我们可以得到函数RemoveNoise(u⊤u^{\\top}u⊤),计算公式如下： vL⊤←u⊤G−1(MGL),vR⊤←u⊤G−1(GR),w⊤←(⌊vL⊤ mod qM⌉,M⌊vR⊤ mod qM⌉)Q,\\begin{array}{l} \\mathbf{v}_{\\mathrm{L}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(M \\mathbf{G}_{\\mathrm{L}}\\right), \\quad \\mathbf{v}_{\\mathrm{R}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{G}_{\\mathrm{R}}\\right), \\\\ \\mathbf{w}^{\\top} \\leftarrow\\left(\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{L}}^{\\top} \\bmod q}{M}\\right\\rceil, M\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{R}}^{\\top} \\bmod q}{M}\\right\\rceil\\right) \\mathbf{Q}, \\end{array} vL⊤​←u⊤G−1(MGL​),vR⊤​←u⊤G−1(GR​),w⊤←(⌊MvL⊤​modq​⌉,M⌊MvR⊤​modq​⌉)Q,​ 这里的Q是什么暂且不深入讲解。 我们定义一个函数RndPad满足： RndPadA(s)=RemoveNoise(s⊤A+e)=s⊤ARndPad_{A}(s)=RemoveNoise(s^{\\top}A+e)=s^{\\top}ARndPadA​(s)=RemoveNoise(s⊤A+e)=s⊤A bootstrapping 接下来是文章中最重要的阶段，我们定义一个 S=(A‾fhe r⊤A‾fhe +efhe ⊤)(R1,…,R(n+1)⌈log⁡2q⌉)−bits⁡(s)⊗G∈Zq(n+1)×m(n+1)⌈log⁡2q⌉ \\begin{array}{l} \\mathbf{S}=\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}}\\left(\\mathbf{R}_{1}, \\ldots, \\mathbf{R}_{(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}\\right) \\\\ -\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G} \\in \\mathbb{Z}_{q}^{(n+1) \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil} \\end{array} S=(r⊤Afhe ​+efhe ⊤​Afhe ​​)(R1​,…,R(n+1)⌈log2​q⌉​)−bits(s)⊗G∈Zq(n+1)×m(n+1)⌈log2​q⌉​​ A‾fhe ,R\\overline{\\mathbf{A}}_{\\text {fhe }},RAfhe ​,R均可以理解为随机矩阵。 我们定义循环编码为： s⊤(Acirc −(1,bit(S))⊗G)+ecirc \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1,\\text{bit}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{circ}} s⊤(Acirc ​−(1,bit(S))⊗G)+ecirc​ 则对于该循环编码，存在 EvalRndPad(Acirc ,A)=HARdPad EvalRndPadS(Acirc ,A,S)=HA,SRdPad \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}) = \\mathbf{H}_{\\mathbf{A}}^{\\text {RdPad }}\\\\ \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} EvalRndPad(Acirc ​,A)=HARdPad ​EvalRndPadS(Acirc ​,A,S)=HA,SRdPad ​ 满足： s⊤(Acirc −(1,bits⁡(S))⊗G)HA,SRdPad =s⊤Acirc HARndPad −RndPad⁡A(s)+efhe ⊤RRndPad A\\begin{aligned} &amp; \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} \\\\ = &amp; \\mathbf{s}^{\\top} \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}}^{\\text {RndPad }}-\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})+\\mathbf{e}_{\\text {fhe }}^{\\top} \\mathbf{R}_{\\text {RndPad }_{\\mathbf{A}}} \\end{aligned} =​s⊤(Acirc ​−(1,bits(S))⊗G)HA,SRdPad ​s⊤Acirc ​HARndPad ​−RndPadA​(s)+efhe ⊤​RRndPad A​​​ 实际上，通过，观察我们可以发现这里将(1,bits⁡(S))(1, \\operatorname{bits}(\\mathbf{S}))(1,bits(S))转化成RndPad⁡A(s)\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})RndPadA​(s),实际上是做了一个RemoveNoise的运算电路， Unbounded Homomorphic Evaluation 这部分运算同EvalC,和EvalCX一样分别分为两部分UEvalC和UEvalX（详见BGG+14）,我们可以这样直观的理解： EvalC/UEvalC: 发声于密钥生成阶段，电路C可以是任意的，属于一种明文态的同态计算。 EvalCX/UEvalCX: 发声于解密阶段，若想要正确解密，电路C必须满足C(x)=1C(x)=1C(x)=1，属于一种密文态的同态计算。 我们来看在论文中的描述： UEvalC UEvalC(Aattr ,Acirc ,C)\\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)UEvalC(Aattr ​,Acirc ​,C) takes as input Aattr ∈Zq(n+1)×(L+1)m,Acirc ∈Zq(n+1)×(LS+1)m\\mathbf{A}_{\\text {attr }} \\in \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\quad \\mathbf{A}_{\\text {circ }} \\in \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m} Aattr ​∈Zq(n+1)×(L+1)m​,Acirc ​∈Zq(n+1)×(LS​+1)m​ and a circuit C:{0,1}L→{0,1}1×L′C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}^{1 \\times L^{\\prime}}C:{0,1}L→{0,1}1×L′ of arbitrary size and depth, where LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^{2}\\left\\lceil\\log _{2} q\\right\\rceil^{2}LS​=m(n+1)2⌈log2​q⌉2. 这里给出了UEvalC的基本算法，注意一下不论是Aattr\\mathbf{A}_{\\text {attr}}Aattr​还是Acirc\\mathbf{A}_{\\text {circ}}Acirc​都是用于构造电路的算法的。先令Aattr=(A0,A1,…,AL)\\mathbf{A}_{\\text {attr}}=\\left (\\mathbf{A}_{0},\\mathbf{A}_{1},\\dots,\\mathbf{A}_{L} \\right )Aattr​=(A0​,A1​,…,AL​), 我们可以先用Acirc\\mathbf{A}_{\\text {circ}}Acirc​做传统的电路运算 HCi′←EvalC⁡((A0,Ai′,Ai′′), gate Ci as one-gate circuit ),Ai′←(A0,Ai′,Ai′′)HCi′\\begin{array}{l} \\mathbf{H}_{C_{i}}^{\\prime} \\leftarrow \\operatorname{EvalC}\\binom{\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right),}{\\text { gate } C_{i} \\text { as one-gate circuit }}, \\\\ \\mathbf{A}_{i}^{\\prime} \\leftarrow\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right) \\mathbf{H}_{C_{i}}^{\\prime} \\\\ \\end{array} HCi​′​←EvalC( gate Ci​ as one-gate circuit (A0​,Ai′​,Ai′′​),​),Ai′​←(A0​,Ai′​,Ai′′​)HCi​′​​ 最后根据上面的运算结果，即： HAi′RndPad←EvalRndPad(Acirc ,Ai′),Ai←Acirc HAi′RndPad\\begin{array}{l} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}} \\leftarrow \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{i}^{\\prime}), \\\\ \\mathbf{A}_{i} \\leftarrow \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}}\\\\ \\end{array} HAi′​RndPad​←EvalRndPad(Acirc ​,Ai′​),Ai​←Acirc ​HAi′​RndPad​​ 这里摘自于原论文，个人感觉符号使用有点混乱了 UEvalCX 这里就是同理了，不再过多赘述，如果在密态情况下EvalCX,计算出来的是形如： AwithLargeNoise′=s⊤(AC−C(x)⊗G)+elarge \\mathbf{A}_{\\text{withLargeNoise}}^{\\prime}=\\mathbf{s}^{\\top}\\left(\\mathbf{A}_{C}-C(x) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{large}} AwithLargeNoise′​=s⊤(AC​−C(x)⊗G)+elarge​ 但是在计算 EvalRndPadS(Acirc ,AwithLargeNoise′,S)=HA,SRdPad \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{\\text{withLargeNoise}}^{\\prime},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }}EvalRndPadS(Acirc ​,AwithLargeNoise′​,S)=HA,SRdPad ​ 中，由于用了循环编码EvalRndPadS可以计算出与EvalRndPad相同的值。 方案 先来看看方案的原算法吧，为了更好的理解以下摘自于原文，我会附上相关的自己的理解 Setup (1L)\\left(1^L\\right)(1L) defines appropriate n,m,q,σ,σ′,σ−1n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1}n,m,q,σ,σ′,σ−1​, σpost \\sigma_{\\text {post }}σpost ​ as described at the end of Section 3, and sets LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^2\\left\\lceil\\log _2 q\\right\\rceil^2LS​=m(n+1)2⌈log2​q⌉2. The algorithm samples: Aattr ←Zq(n+1)×(L+1)m,Acirc ←Zq(n+1)×(LS+1)m,(B,τ)←TrapGen⁡(1n,1m,q),z←Zqn\\begin{aligned} \\mathbf{A}_{\\text {attr }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\\\ \\mathbf{A}_{\\text {circ }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m}, \\\\ (\\mathbf{B}, \\tau) &amp; \\leftarrow \\operatorname{TrapGen}\\left(1^{n}, 1^{m}, q\\right), \\quad \\mathbf{z} \\leftarrow \\mathbb{Z}_{q}^{n} \\end{aligned} Aattr ​Acirc ​(B,τ)​←Zq(n+1)×(L+1)m​,←Zq(n+1)×(LS​+1)m​,←TrapGen(1n,1m,q),z←Zqn​​ It outputs mpk=(n,m,q,σ,σ′,σ−1,σpost ,Aatt ,Acirc ,B,z),msk=(mpkτ)\\mathrm{mpk}=\\binom{n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1},}{\\sigma_{\\text {post }}, \\mathbf{A}_{\\text {att }}, \\mathbf{A}_{\\text {circ }}, \\mathbf{B}, \\mathbf{z}}, \\mathrm{msk}=\\binom{\\mathrm{mpk}}{\\tau}mpk=(σpost ​,Aatt ​,Acirc ​,B,zn,m,q,σ,σ′,σ−1​,​),msk=(τmpk​). 启动阶段，生成陷门和循环电路参数以及属性参数。 KeyGen(msk,C)(msk, C)(msk,C) takes msk,C:{0,1}L→{0,1}msk, C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}msk,C:{0,1}L→{0,1} as input. It computes AC←UEvalC(Aattr ,Acirc ,C)\\mathbf{A}_{C} \\leftarrow \\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)AC​←UEvalC(Aattr ​,Acirc ​,C) and samples z′←Zqn+1\\mathbf{z}^{\\prime} \\leftarrow \\mathbb{Z}_{q}^{n+1}z′←Zqn+1​. The algorithm generates a trapdoor k←$SimplD(B,τ,A‾CG−1(z′)+z,σ−1),k \\stackrel{\\$}{\\leftarrow} \\text{SimplD}(\\mathbf{B},\\tau,\\overline{\\mathbf{A}}_{C}G^{-1}(z')+z,\\sigma_{-1}), k←$SimplD(B,τ,AC​G−1(z′)+z,σ−1​), whereA‾C∈Zqn×m\\overline{\\mathbf{A}}_{C} \\in \\mathbb{Z}_{q}^{n \\times m}AC​∈Zqn×m​ is the the first nnn rows of AC\\mathbf{A}_{C}AC​. The algorithm outputs skC=(z′,k)\\mathrm{sk}_{C}=\\left(\\mathbf{z}^{\\prime}, \\mathbf{k}\\right)skC​=(z′,k). 这里做了UEvalC计算，并且运用了陷门，生成密钥，若想要解密，必须生成相同的值 可以理解为用陷门对ACA_{C}AC​进行了一次签名，只不过这种签名是密态的。 Enc (mpk,x,μ)(\\mathrm{mpk}, \\mathbf{x}, \\mu)(mpk,x,μ) takes mpk,x∈{0,1}L,μ∈{0,1}mpk, \\mathbf{x} \\in\\{0,1\\}^{L}, \\mu \\in\\{0,1\\}mpk,x∈{0,1}L,μ∈{0,1} as input. It samples r←DZ,σ,≤σλn\\mathbf{r} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{n}r←DZ,σ,≤σλ​n​ and sets s←(r⊤,−1)⊤\\mathbf{s} \\leftarrow\\left(\\mathbf{r}^{\\top},-1\\right)^{\\top}s←(r⊤,−1)⊤. The algorithm creates a circular encryption by A‾fhe ←&amp;Zqn×m,efhe ←&amp;DZ,σ,≤σλmR←${0,1}m×m(n+1)⌈log⁡2q⌉,Afhe ←(A‾fhe r⊤A‾fhe +efhe ⊤), S←Afhe R−bits⁡(s)⊗G,\\begin{array}{l} \\overline{\\mathbf{A}}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathbb{Z}_{q}^{n \\times m}, \\quad \\mathbf{e}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{m}\\\\ \\mathbf{R} \\stackrel{\\$}{\\leftarrow}\\{0,1\\}^{m \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}, \\\\ \\mathbf{A}_{\\text {fhe }} \\leftarrow\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}} \\text {, } \\\\ \\mathbf{S} \\leftarrow \\mathbf{A}_{\\text {fhe }} \\mathbf{R}-\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G}, \\\\ \\end{array} Afhe ​←&amp;Zqn×m​,efhe ​←&amp;DZ,σ,≤σλ​m​R←${0,1}m×m(n+1)⌈log2​q⌉,Afhe ​←(r⊤Afhe ​+efhe ⊤​Afhe ​​), S←Afhe ​R−bits(s)⊗G,​ than encoding by eattr ←DZ,σ′,≤σ′λ(L+1)m,ecirc ←DZ,σ′,≤σ′λ(Ls+1)m,cattr ⊤←s⊤(Aattr −(1,x⊤)⊗G)+eattr ⊤,ccirc ⊤←s⊤(Acirc −(1,bits⁡(S))⊗G)+ecirc ⊤.\\begin{array}{l} \\mathbf{e}_{\\text {attr }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L+1) m}, \\quad \\mathbf{e}_{\\text {circ }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L \\mathbf{s}+1)m}, \\\\ \\mathbf{c}_{\\text {attr }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {attr }}-\\left(1, \\mathbf{x}^{\\top}\\right) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {attr }}^{\\top}, \\\\ \\mathbf{c}_{\\text {circ }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {circ }}^{\\top} . \\end{array} eattr ​←DZ,σ′,≤σ′λ​(L+1)m​,ecirc ​←DZ,σ′,≤σ′λ​(Ls+1)m​,cattr ⊤​←s⊤(Aattr ​−(1,x⊤)⊗G)+eattr ⊤​,ccirc ⊤​←s⊤(Acirc ​−(1,bits(S))⊗G)+ecirc ⊤​.​ It also generates the message encoding as eB←DZ,σpost ,≤σpost λm,emsg←DZ,σ′,≤σ′λcB⊤←r⊤B+eB⊤,cmsg←r⊤z+emsg+μ⋅⌊q/2⌉.\\begin{aligned} \\mathbf{e}_{\\mathrm{B}} &amp; \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma_{\\text {post }}, \\leq \\sigma_{\\text {post }} \\sqrt{\\lambda}}^{m}, \\quad e_{\\mathrm{msg}} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}} \\\\ \\mathbf{c}_{\\mathrm{B}}^{\\top} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{B}+\\mathbf{e}_{\\mathrm{B}}^{\\top}, \\\\ c_{\\mathrm{msg}} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{z}+e_{\\mathrm{msg}}+\\mu \\cdot\\lfloor q / 2\\rceil . \\end{aligned} eB​cB⊤​cmsg​​←DZ,σpost ​,≤σpost ​λ​m​,emsg​←DZ,σ′,≤σ′λ​​←r⊤B+eB⊤​,←r⊤z+emsg​+μ⋅⌊q/2⌉.​ The algorithm outputs ctx=(S,cattr,ccirc,cB,cmsg)ctx = (S, c_{attr}, c_{circ}, c_{B}, c_{msg})ctx=(S,cattr​,ccirc​,cB​,cmsg​). 与BGG+14不同的是生成了一个循环编码的密文。 Dec (A‾Ca‾C⊤)=AC←UEvalC⁡(Aatr ,Acirc ,C),cC,x⊤←UEvalCX⁡(Aattr ,cattr ⊤,Acirc ccirc ⊤,C,x,S),c′←cmsg+cC,x⊤G−1(z′)−(cB⊤k−a‾C⊤G−1(z′)).\\begin{aligned} \\binom{\\overline{\\mathbf{A}}_{C}}{\\underline{\\mathbf{a}}_{C}^{\\top}} &amp; =\\mathbf{A}_{C} \\leftarrow \\operatorname{UEvalC}\\left(\\mathbf{A}_{\\text {atr }}, \\mathbf{A}_{\\text {circ }}, C\\right), \\\\ \\mathbf{c}_{C, \\mathbf{x}}^{\\top} &amp; \\leftarrow \\operatorname{UEvalCX}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{c}_{\\text {attr }}^{\\top}, \\mathbf{A}_{\\text {circ }} \\mathbf{c}_{\\text {circ }}^{\\top}, C, \\mathbf{x}, \\mathbf{S}\\right), \\\\ c^{\\prime} &amp; \\leftarrow c_{\\mathrm{msg}}+\\mathbf{c}_{C, \\mathbf{x}}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)-\\left(\\mathbf{c}_{\\mathrm{B}}^{\\top} \\mathbf{k}-\\underline{\\mathbf{a}}_{C}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)\\right) . \\end{aligned} (a​C⊤​AC​​)cC,x⊤​c′​=AC​←UEvalC(Aatr ​,Acirc ​,C),←UEvalCX(Aattr ​,cattr ⊤​,Acirc ​ccirc ⊤​,C,x,S),←cmsg​+cC,x⊤​G−1(z′)−(cB⊤​k−a​C⊤​G−1(z′)).​ 最后我们对上文所有组件的分析，由与在密态下计算一个UEvalCX可以消除掉在属性电路CCC生成的噪声，因此最后的噪声与CCC无关，仅与removeNoise电路编码的生成的噪声有关，但是removeNoise是一个固定值，所以实现了一个电路无界的功能。","link":"2024/05/28/YHJ23/"},{"title":"常见漏洞原理","text":"在这篇文章中我会收录一些常见的漏洞及其原理，同时分析抵御该漏洞的相关方法，即能够加强在做研发过程中的安全意识，也能为结合后面学习spring security打下基础。 SQL注入 简介 在输⼊的字符串中注⼊SQL指令，这些注⼊的恶意指令会被数据库服务器误认为是正常的SQL指令⽽允许，系统因此遭到破坏或是⼊侵。 SQL注入主要分为以下几类： • 基于布尔类型的盲注，即可以根据返回⻚⾯判断条件真假的注⼊。 • 基于时间的盲注，即不能根据⻚⾯返回的内容判断任何信息，要⽤条 件语句查看时间延迟语句是否⼰执⾏（即⻚⾯返回时间是否增加）来判 断。 • 基于报错注⼊，即⻚⾯会返回错误信息，或者把注⼊的语句的结果直 接返回到⻚⾯中。 • 联合查询注⼊，在可以使⽤Union 的情况下的注⼊。 • 堆查询注⼊，可以同时执⾏多条语句时的注⼊。 基于布尔类型的盲注 适⽤场景：后端执行sql执⾏的结果不会直接显示在前端，但是会在前端显示正确或者错误。 布尔注入的的原理： 获取数据库名字的⻓度： select length(DATABASE())。 截取字符, 使用 123select MID('string',2,2);select substr('string',2);select left('string',2); 其中substr 和 MID作⽤⼀样，left是从字符串左边截取字符. 3. 为了⽅便遍历，⽤到for循环，适⽤ASCII：ASCII 和 ARD作⽤⼀样 通过以上方法进行枚举，先猜⻓度，再猜每⼀位上的字符，获取库名，表名，列名，数据（字段值）。 也可以使⽤⼆分法去暴⼒枚举，这样更快，例如：⻓度&gt;=8是否成⽴ 基于时间的盲注 适⽤场景：既没有数据回显，也不会在sql语句正确与否时显示不同的内容。(即前端不会显示任何信息) 基于时间的盲注原理：利用判断条件和sql中的sleep方式判断条件是否正确。（可以理解为在数据库端端一种布尔注入，原本前端没有任何显示信息，可以通过反应时间了解正确或错误） 如利用： 123select sleep(if(select length(database())=8),1,0);select if(length(database())=8,sleep(1),0);-- 两者等价 基于报错的注⼊ 这个比较好理解，前端会把后台报错的信息打印出来. extractValue()是一个 XML 处理函数，它从给定的 XML 片段中提取值。通过构造一个不正确的 XML 片段，可以触发一个错误消息，其中包含我们插入的恶意数据。 updatexml() 是一个 XML 更新函数，用于更新给定 XML 片段中的节点。通过构造一个不正确的 XML 更新语句，同样可以触发一个错误消息。 实例如下： 12select extractValue('',concat('-',database()));select updatexml('',concat('-',database()),''); 会分别产生如下报错信息 对于 extractValue()： 1SQL Error (1105): XPATH syntax error: '-'database_name 对于 updatexml()： 1SQL Error (1105): XPATH syntax error: '-'database_name SQL注入的基本流程 判断是否有sql注⼊漏洞,方法如下： 加⼀个单引号’，看是否出错，因为引号必须成对出现，否则会出错（判断是否能注入）。 两次尝试 1=1 正常输出，1=2错误输出，证明SQL语句⽣效，存在SQL注⼊漏洞（判断是否能布尔注入）。 1select first_name,last_name from user where user_id='1'and 1=#'; 获得数据库名,可利用union等类似的联合查询 获得表名 获取列名 获得数据 获取对应元数据的方法依然是采用遍历查找的办法。 防御方法 根源问题：服务端把⽤户输⼊当作命令执⾏ 校验⽤户输⼊参数，过滤连接符 对用户输入转义 数据库异常信息隐藏，将异常进⾏封装，防⽌基于报错的SQL注⼊ 数据库敏感信息加密，⽤MD5哈希的时候，记得加盐 安装web应⽤防⽕墙WAF 将输⼊进⾏参数化 命令注入漏洞 和sql注入类似，将用户对输入当成shell命令去执行。这里不赘述了 文件上传漏洞 简介 前端⻚⾯需要⽤户上传⽂件的时候，攻击者上传恶意的⽂件，⽐如上传后⻔病毒⽊⻢到⽹站中，⽹站因此遭到破坏或是⼊侵。 防御方法 这里给几个简单的防御手段。 代码层面： 在前后端增加文件校验接口 对文件进行内容二次渲染 重命名文件，将文件隔离出来，访问时只访问文件的路径。 管理层面： 部署WAF防⽕墙 正确配置服务器请求类型(禁⽌使⽤PUT请求⽅法) 及时更新系统、中间件、脚本、数据库、CMS或框架的漏洞补丁(避免解析漏洞) 权限控制层面： 限制上传⽬录下拥有的执⾏权限 XSS跨站脚本攻击 原理：跨站脚本攻击利⽤了⽹站对⽤户输⼊的不正确处理，使得恶意⽤户能够向受害者的⽹⻚中注⼊恶意脚本。这些脚本在⽤户浏览器中执⾏，从⽽ 导致安全⻛险。跨站脚本攻击的主要原理包括： ⽤户输⼊未经过滤或转义：⽹站未正确过滤或转义⽤户输⼊，使得恶意⽤户能够插⼊恶意脚本。 脚本在⽤户浏览器中执⾏：⼀旦恶意脚本被注⼊到受害者的⽹⻚中，它将在⽤户浏览器中执⾏，攻击者可利⽤此执⾏环境进⾏进⼀步攻击。 常见的事发网站：日志，小说，论坛等内容存储网站。 XSS攻击类别 反射型 XSS 反射型 XSS 是最常⻅的 XSS 攻击类型。攻击者构造恶意的 URL，其中包含恶意脚本。当⽤户点击带有恶意参数的 URL 时，服务器将恶意脚本作 为响应的⼀部分返回给⽤户浏览器，并在浏览器中执⾏。 存储型 XSS 存储型 XSS 发⽣在⽹站存储⽤户提交的数据，且未经过滤或转义的情况下直接在⽹⻚中显示。攻击者提交包含恶意脚本的数据，然后其他⽤户在访问包含该数据的⻚⾯时，恶意脚本将在他们的浏览器中执⾏。 DOM型 XSS DOM 型 XSS 是基于⽂档对象模型（Document Object Model，DOM）的⼀种XSS攻击。攻击者构造恶意URL，其中包含恶意脚本。当⽤户点击包含恶意参数的URL时，恶意脚本修改⻚⾯的 DOM 结构，从⽽导致安全漏洞。 利用流程 总体通过四种途径来利用： 输入字段和表单 URL参数 富文本编辑器 防御方法 为了有效防御跨站脚本攻击，以下是⼀些常⻅的防御措施： 输⼊验证和过滤 ⽹站应该对⽤户输⼊的数据进⾏验证和过滤，确保只接受预期的输⼊。例如，可以使⽤⽩名单过滤，只允许特定字符和标记，同时拒绝其他 潜在的恶意脚本。 输出转义 在将⽤户输⼊的数据显示在⽹⻚中时，应该对其进⾏适当的输出转 义，以确保浏览器将其视为纯⽂本⽽不是可执⾏的代码。这样可以防⽌恶 意脚本在⽤户浏览器中执⾏。 设置 HTTP 头部 通过设置适当的 HTTP 头部，可以增强⽹站的安全性。例如，可以使⽤ Content Security Policy（CSP）来限制⻚⾯中允许执⾏的脚本来源，从⽽减少跨站脚本攻击的⻛险。 CSRF跨站请求伪造 原理:攻击者通过伪造⽤户的浏览器的请求，向访问⼀个⽤户⾃⼰曾经认证访问过的⽹站发送出去，使⽬标⽹站接收并误以为是⽤户的真实操作⽽去执⾏命令。常⽤于盗取账号、转账、发送虚假消息等。攻击者利⽤⽹站对请求的验证漏洞⽽实现这样的攻击⾏为，⽹站能够确认请求来源于⽤户的浏览器，却不能验证请求是否源于⽤户的真实意愿下的操作⾏为。 CSRF等攻击流程 用户浏览并登录信任的网站 A，通过用户认证后，会在浏览器中生成针对 A 网站的 Cookie； 用户在没有退出网站 A 的情况下访问网站 B，然后网站 B 向网站 A 发起一个请求； 用户浏览器根据网站 B 的请求，携带 Cookie 访问网站 A； 由于浏览器会自动带上用户的 Cookie，所以网站 A 接收到请求之后会根据用户具备的权限进行访问控制，这样相当于用户本身在访问网站 A，从而网站 B 就达到了模拟用户访问网站 A 的操作过程。 关于CORS 这里我想要提一嘴cors,经常做研发的小伙伴都知道，跨域问题在我们日常开发中特别常见。 由于当下的 Web 应用程序开发基本都采用了前后端分离的开发模式，例如，当我们访问“test.com”前端域名时，在前端中会访问“api.test.com”后端路由获得服务。但是这个请求已经跨越了两个域名，因此浏览器默认会拒绝这种访问。 请注意，跨域是浏览器的一种同源安全策略，是浏览器单方面限制的，所以仅在客户端运行在浏览器中才需要考虑这个问题。 浏览器在 HTTP 请求的消息头部分新增一些字段，如下所示： 123456//浏览器自己设置的请求域名Origin //浏览器告诉服务器请求需要用到哪些 HTTP 方法Access-Control-Request-Method//浏览器告诉服务器请求需要用到哪些 HTTP 消息头Access-Control-Request-Headers 当浏览器进行跨域请求时会和服务器端进行一次的握手协议，从响应结果中可以获取如下信息: 123456//指定哪些客户端的域名允许访问这个资源Access-Control-Allow-Origin //服务器支持的 HTTP 方法Access-Control-Allow-Methods //需要在正式请求中加入的 HTTP 消息头Access-Control-Allow-Headers 综上所述，浏览器在跨域请求时会和服务器通信访问的方法和访问的源域名。而服务器恰好可以设置允许哪些域名可以访问，那么我们就知道如何解决CORS问题了：服务器合理设置这些响应结果中的消息头。 就是我们开发中经常使用的CorsFilter 123config.setAllowedOrigins(Arrays.asList(&quot;*&quot;));config.setAllowedMethods(Arrays.asList(&quot;*&quot;)); 通过这样的配置使得所有请求可以跨域访问。注意这样配置的重点是让浏览器能够将所有其他域的请求转发给服务器，如果要防止CSRF类的攻击，后端还是要对所有请求做校验。 小结一下：CSRF 是一种攻击行为，所以我们需要对系统进行保护，而 CORS 更多的是一种前后端开发模式上的约定。 防御方法 验证 HTTP Referer 字段:根据 HTTP 协议，在 HTTP 头中有⼀个字段叫 Referer，它记录了该 HTTP 请求的来源地址。服务端只需要娇艳请求验证其 Referer 值。 在请求地址中添加 token 并验证:可以在 HTTP 请求中以参数的形式加⼊⼀个随机产⽣的token，并在服务器端建⽴⼀个拦截器来验证这个 token，如果请求中没有token 或者 token 内容不正确，则认为可能是 CSRF 攻击⽽拒绝该请求。 这里补充几个小知识点： 浏览器在Post请求中自动带上cookie的条件（假设请求http://aaa.www.com/xxxxx/list）： 1、domain=域名,或者为其子域名（aaa.www.com 和www.com） 2、仅在 HTTPS 安全通信时才会发送 Cookie 3、path=PATH 注意：每个cookie都存在着domain和path存储cookie来自的域和请求路径。 CSRF token 不会自动被浏览器附带在请求中，需要开发者显式添加。这意味着攻击者不能仅凭 cookie 发起有效请求，因为缺少正确的 token。所以token可以抵御csrf攻击 在 HTTP 头中⾃定义属性并验证: SSRF 服务端请求伪造 SSRF （Server-Side Request Forgery），服务器端请求伪造，是强制服务器发起由攻击者伪造的请求的⼀种安全漏洞。 请求伪造，就是攻击者伪造正常的请求，以达到攻击的⽬的，就是常⻅的Web安全漏洞之⼀。如果“请求伪造”发⽣在服务器端，那么这个漏洞就叫做“服务器端请求伪造”。 漏洞原因 服务端提供了从其他服务器应⽤（也可以是本地）获取数据的功能；服务端对⽤户提供的URL和远端服务器返回的信息没有进⾏合适的验证或者过滤。 漏洞利用流程 当攻击者想要访问服务器B上的服务，但是由于存在防火墙或者服务器B是属于内网主机等原因导致攻击者无法直接访问。如果服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，达到攻击内网的目的。如图 这里我们可以推断出，在服务端提供重定向访问的服务如RedirectView.setURL等，容易存在SSRF漏洞 OK，这篇文章的内容就先到这，后面再补充一些安全相关的知识","link":"2024/06/05/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"并发编程","slug":"并发编程","link":"tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"工具","slug":"工具","link":"tags/%E5%B7%A5%E5%85%B7/"},{"name":"源码解析","slug":"源码解析","link":"tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"hexo","slug":"hexo","link":"tags/hexo/"},{"name":"Lattice","slug":"Lattice","link":"tags/Lattice/"},{"name":"ABE","slug":"ABE","link":"tags/ABE/"},{"name":"安全","slug":"安全","link":"tags/%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"java","slug":"java","link":"categories/java/"},{"name":"工作","slug":"工作","link":"categories/%E5%B7%A5%E4%BD%9C/"},{"name":"基于格的属性基加密","slug":"基于格的属性基加密","link":"categories/%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/"},{"name":"网络安全","slug":"网络安全","link":"categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"pages":[]}