{"posts":[{"title":"AQS与JUC","text":"在读这篇文章之前最好读读我前面的这篇文章：Java并发编程。 在这篇文章中我打算详细讲讲JUC包的几种锁，后面再补上AQS的源码分析。 首先我们明确一个区别，synchronized是由java JVM实现的，而Lock是由java JDK实现的。以下列了几个不同点 Synchronized是Java的内置关键字，Lock是一个java接口。 Synchronized无法判断获取锁的状态，Lock可以通过java.lang.Thread 中的holdsLock()方法判断是否获得某个对象的锁。 Synchronized会自动释放锁，Lock必须手动释放锁，否则可能产生死锁（手动使用lock和unlock方法）。 如果一个线程获得了锁，对于Synchronized来说其他需要使用这个资源的线程就只能等待下去，如果获得了锁的线程进入阻塞状态，其他线程依旧会等待，Lock锁就不一定会一直等待下去，可以通过tryLock尝试获取锁（线程是否等待）。 Synchronized是可重入锁，不可以中断，非公平的，Lock可重入锁，可以判断锁的状态，是否公平可以通过fair参数进行设置，相对而言比较灵活。 概述 首先我们从JUC包开始 我们首先了解JUC包下的几种锁 ReentrantLock重入锁 重入锁可以完全替代 synchronized 关键字。在java早期版本中，重入锁的性能远大于synchronized。但从JDK6.0开始，JDK在synchronized上做了大量的优化，使得两者的性能差距并不大。重入锁对逻辑控制的灵活性要远远好于synchronized。 使用方法比较简单： 123public ReentrantLock lock = new ReentrantLock();lock.lock();lock.unlock(); 这里注意，每个unlock()必须对应一个lock(),必须形成闭包。若unlock()数大于lock()数，则会抛出异常。 中断响应lockInterruptibly() 如果使用 synchronized ，要么获得锁，要么保持等待。而如果使用了重入锁，则提供了另一种可能，那就是线程可以被中断。也就是在等待锁的过程中，程序可以根据需要取消对锁的请求。即：如果一个线程正在等待锁，那么它依然可以收到一个通知，被告知无须再等待，可以停止工作了。 而使用synchronized的锁要想停止线程，必须先获得锁，才能继续继续执行 123456789101112131415161718192021static class ReentrantLockThread implements Runnable { private ReentrantLock lock; public ReentrantLockThread(ReentrantLock lock) { this.lock = lock } @Override public void run() { try { lock.lockInterruptibly(); // 获得lock1的可中断锁 System.out.println(Thread.currentThread().getName() + &quot;，加锁成功！&quot;); } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + &quot;，发生异常！&quot;); e.printStackTrace(); } finally { lock.unlock(); System.out.println(Thread.currentThread().getName() + &quot;，lock解锁成功！&quot;); } }} 使用lockInterruptibly(),既是获取中断锁，若在此过程中发生异常，进程可以直接退出，这样的设计可以防止发生死锁。 tryLock(long time, TimeUnit unit) 1lock.tryLock(500, TimeUnit.MILLISECONDS) 该方法为在一定时间内试图获取锁，失败则返回。 tryLock()方法也可以不带参数直接运行。在这种情况下，当前线程会尝试获得锁，如果锁并未被其他线程占用，则申请锁会成功，并立即返回true。如果锁被其他线程占用，则当前线程不会进行等待，而是立即返回false。 公平锁和非公平锁 在默认的情况下，锁的申请是非公平锁。我们知道sychronized在进入waitqueue时都会先经过几轮空循环,这个线程是有权利进行锁的争抢，所以sychronized锁是非公平的。 在默认情况下，ReentrantLock同样是非公平的，默认输入参数为false,当输入参数为true时，锁会转换成公平锁。公平锁默认会维护一个队列，这个我们以后再讲。 Condition重入锁 在使⽤内置锁synchronized时，通过调⽤Objec中定义的监视器⽅法，主要有wait(),wait(long timeout),notify()和notifyAll()⽅法，可以实现等待/通知模式。Codition接⼝中也定义了类似的监视器⽅法，与显示锁Lock配合使⽤也可以实现等待/ 通知模式。 常用方法方式如下 123Condition.await() //等待线程Condition.signal() //唤醒一个线程Condition.signalAll() //唤醒所有线程 Semaphore 信号量 synchronized和ReentrantLock机制都只允许获取锁（锁资源只有一个）的线程去访问资源，换而言之，只允许一个线程去访问资源。而Semaphore扩展了这种机制，可以指定多个线程同时访问某一个资源。 常用方法如下： 1234567891011void acquire(); //尝试获得⼀个准⼊的许可。若⽆法获得，则线程会等待，直到有线程释放⼀个 许可或者当前线程被中断。 void acquireUninterruptibly(); //具有acquire⼀样的功能，但是不响应中断 （Uninterruptibly）。 void tryAcquire(); //尝试获得⼀个许可，如果成功就⽴即返回true，失败则⽴即返回false。 void tryAcquire(long timeout, TimeUnit unit); //在指定时间内，尝试获得⼀个许可，如果成功 就返回true，失败则返回false。 void release(); 资源访问结束后，释放⼀个许可。 CountDownLatch倒计时器 CountDownLatch是⼀个多线程控制⼯具。⽤来控制线程的等待。设置需要countDown的数量num，然后每⼀个线程执⾏完毕后，调⽤countDown()⽅法，⽽主线程调⽤await()⽅ 法执⾏等待，直到num个⼦线程执⾏了countDown()⽅法 ，则主线程开始继续执⾏。 这个有点类似线程控制包里的join()方法。 ReadWriteLoc读写锁 ReadWriteLock由JDK5提供，它允许多个线程同时读。但是考虑到数据的完整性，写写操作和读写操作间依然是需要相互等待和持有锁的。 读 写 读 非阻塞 阻塞 读 阻塞 阻塞 如果在系统中，读操作的次数远远⼤于写操作，那么读写锁就可以发挥最⼤的效果， 提升系统的性能 CyclicBarrier循环栅栏 CyclicBarrier与CountDownLatch⾮常类似，它⽀持计数器的反复使⽤，CyclicBarrier可以理解为循环栅栏。CyclicBarrier可以接收⼀个参数作为Runnable barrierAction，每当计数器⼀次计数完成后——CyclicBarrier.await()时，系统会执⾏的动作。 LockSupport线程阻塞⼯具类 在之前的笔记中我们知道Thread.suspent,Thread.resume已经被废弃了，原因是如果使用不当，当先执行resume,后执行suspend将导致线程被永久阻塞。LockSupport类改善了这一情况，同时相比于使用监视器wait()或者Condition.await(),LockSupport不需要事先获取锁。 LockSupport包含两个方法，part,unpart。我们看看LockSupport是如何实现防止先调用unpart,后调用part导致线程被永远阻塞。 每⼀个线程都有⼀个许可，该许可默认为 不可⽤。如 果该许可是可⽤状态，那么park()⽅法会⽴即返回，消费这个许可，将该许可变更为不可⽤状态，流程代码可以继续执⾏。如果该许可是不可⽤状态，那么park()⽅法 将会阻塞；unpark⽅法，将指定线程的⼀个许可变为可⽤状态。 状态变化如表所示： 当前许可状态 调用后许可状态 park 可用 不可用 park 不可用 阻塞 unpark 可用 可用 unpark 不可用 可用 简而言之，经过unpart操作除阻塞状态变成非阻塞状态,其他所有状态都会变成可用状态，而当状态为不可用时是正常状态，若为可用，说明前面经过一次unpark,则调用park会将状态变回不可用状态。 同时注意park阻塞线程支持被中断，且中断后不会抛出InterruptedException异常。","link":"2024/06/04/AQS%E4%B8%8EJUC/"},{"title":"AQS源码解析(二)","text":"在读本文之前，希望你已经阅读了AQS与JUC 概论 如下图所示，AQS类的继承关系：所有的锁均继承了 而AQS的结构如图所示： 123public ReentrantLock() { sync = new NonfairSync();} 由源码可得，默认构造的可重入锁是非公平锁。此外可以通过输入boolean值来构造公平锁： 123public ReentrantLock(boolean fair) { sync = fair ? new FairSync() : new NonfairSync();} 公平锁与非公平锁 acquire 12345public final void acquire(int arg) { if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();} boolean tryAcquire(int acquires)：抢锁操作，返回是否成功。这里若抢锁失败则进入下一阶段，判断是否应该挂起线程。 boolean acquireQueued(final Node node, int arg)：判断当获取锁失败时是否挂起线程，若是则挂起线程。 Node addWaiter(Node) node：构建一个独占模式的节点，并维护好当前节点的前后指针 tryAcquire(arg) 默认入参为1，该方法的功能为抢锁操作，公平锁和非公平锁的抢锁操作是不同的。 公平锁-FairSync 这里不粘原码了，给出公平锁的流程图。 非公平锁-NonfairSync","link":"2024/06/16/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"Kafka应用及其原理","text":"这章将会介绍消息队列中间件，本章除了介绍Kafka中间件还会介绍几种常见的中间件。在学习中间件的时候一定要注意横向选型能力。 常用的MQ介绍 Kafka 概述： 最初由LinkedIn公司基于独特的设计实现为一个分布式的日志提交系统。(要求快，但是允许低丢失)。 其性能高效（快），可扩展性好（很多公司选择在此结构上扩展），可持久化，且分区特性使其可复制、容错均不错。 优点： 客户端支持的语言丰富。 高性能：单机写入TPS约在100万条/秒，消息大小10个字节。 消费者采用Pull方式获取消息。消息有序，通过控制能够保证所有消息被消费且仅被消费一次。 缺点： Kafka单机超过64个队列/分区时，Load时会发生明显的飙高现象。队列越多，负载越高，发送消息响应时间变长。 使用短轮询方式，实时性取决于轮询间隔时间。 消费失败不支持重试。 RocketMQ 概述：RocketMQ出自阿里的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进（支持几十种消息收发的方式，串行，阻塞式，基于sql等等），消息可靠性上比Kafka更好。 RabbitMQ 概述：稳定性极高，用户界面非常友好。它提供了多种技术可以让你在性能和可靠性之间进行权衡。这些技术包括持久性机制、投递确认、发布者证实和高可用性机制；灵活的路由，消息在到达队列前是通过交换机进行路由的。 Kafka配置 属性 默认值 描述 broker.id 0 每个broker的唯一标志符 ｜ log.dirs /tmp/kafka-logs kafka存放数据的路径 ｜ listeners PLAINTEXT://192.168.65.60.9092 kafka的监听ip zookerper.connect localhost:2181 zk集群中的节点 num.partitions 1 创建topic的默认分区数 default.replication.factor 1 自动创建topic的默认副本数量，建立设置为大于等于2 ｜ min.insync.replicas ｜ 1 ｜ 指定消息成功写入时，最小的副本同步数量 ｜ 基本概念 名词 解释 Broker 【节点】一个Kafka节点就是一个Broker，一个和多个Broker可以组成一个Kafka集群 Topic 【主题】Kafka根据topic对消息进行归类，发布到kafka集群的每套消息都需要指定一个topic，topic是一个逻辑概念，物理上是不存在的 Producer 【生产者】用于向Kafka中发送消息 Consumer 【消费者】从Kafka中获取消息 Consumer Group 【消费组】每个Consumer都会归属于一个消费组，一条消息可以同时被多个不同的消费组消费，但是只能被一个消费组中的消费者消费 Partition 【分片】物理上的概念，可以将一个topic上的数据拆分为多分放到Partition中，每个Patition内部的消息是有序的。 Kafka的存储结构 消息是会被存储在kafka中的文件里的，并且是顺序存储的，消息有偏移量的概念，所以我们可以指定偏移量去读取某个位置的消息。 单播消息和多播消息 所谓的单播消息和多播消息就是根据消费者是否在统一消费组中消费组中。 单播消息 概述：一个消费组里，只会有一个消费者能够消费到某个topic中的消息。 多播消息 概述：一个topic下单消息被多个消费者消费。 架构图如下（引自JavaGuide） 稀疏索引 kafka收发消息速度快，那么在底层Kafka是如何存储消息的呢？在Kafka内部消息都是存在磁盘里的，所有的消息按照顺序写入磁盘（我们知道磁盘读写是慢于内存读写的。但是磁盘的顺序读写实际上和内存读写的速度差不多，而随机读写远远的慢于内存。Kafka使用在内存中顺序读写消息，使得消息收发快）。内部索引结构如下： Kafka集群 这里有几个概念注意下： 分区：一个主题中的消息量是非常大的，因此可以通过分区的设置，来分布式存储这些消息。 副本：那么为了提高系统的可用性。我们把分片复制多个，这就是副本了。 Leader:kafka的读写操作都发生在leader上，leader负责把数据同步给follower。若Leader挂掉了，那么经过主从选举，从多个follower中选举产生一个新的leader。 Follower:follower接收leader同步过来的数据，它不提供读写（主要是为了保证多副本数据与消费的一致性） 多分区消费组 消息队列模型如下，（引自javaguide） 在每个topic中，存在一个或多个partition。为了维护消息的有序性一个partition只能被一个消费组中的一个消费者消费（同一组的消费者消费消息是互斥），但是在多个partition的多个消费者消费的总顺序性是无法得到保证的（从这里可以看出如果要实现消息的有序性，用一个partition就可以了）。 partition的数量决定了消费组中Consumer的数量，建议同一个消费组中的Consumer数量不要超过partition的数量，否则多余的Consumer就无法消费到消息了。但是，如果消费者挂掉了，那么就会触发rebalance机制，会由其他消费者来消费该分区。 重平衡（Rebalance） 在重平衡之前，一个consumer gruop中有多个consumer组成，一个topic有多个partition组成，如何确定哪个consumer消费哪个分区？消费者消费有三种策略。 Range：通过公式来计算某个消费者消费哪个分区 RoundRobin：大家轮流对分区进行消费 sticky：在触发rebalance之后，在消费者消费的原分区不变的基础上进行调整。 controller 概述：Kafka集群中的Broker在ZK中创建临时序号节点，序号最小的节点也就是最先创建的那个节点，将作为集群的Controller，负责管理整个集群中的所有分区和副本的状态。 八股 如何防止消息丢失 对于发送方： 将ack设置为1或者-1/all可以防止消息丢失，如果要做到99.9999%，ack要设置为-1/all。 针对消费方： 把自动提交修改为手动提交。（防止消费异常，导致消息丢失） acks 消息持久化机制 -1/all acks=all就意味着ISR列表里面的副本必须都要同步成功，才返回ack给消息队列，min.insync.replicas 这个配置是用来设置同步副本个数的下限，此时这个配置无效 0 表示producer不需要等待任何broker确认收到消息的ACK回复，就可以继续发送下一条消息。性能最高，但是最容易丢失消息 1 表示至少等待leader已经成功将数据写入本地日志，但是不需要等待所有follower都写入成功，就可以继续发送下一条消息。 针对接收方： 防止消息的重复消费 加入幂等处理： 通过mysql插入业务id作为主键，因为主键具有唯一性，所以一次只能插入一条业务数据。 使用redis或zk的分布式锁，实现对业务数据的幂等操作。 实现顺序消费 发送方：当收到ack时才继续发送消息，但只能保证，topic里面是有序的。 接收方；在topic里只配置一个partition，或者consumer组里只有一个consumer 解决消息积压问题 解决思路：消息积压是因为消费者处理速度太慢，从消费者端进行处理。 消费者采用多线程，或者增加消费者数量。 对消费逻辑设置最大处理时延，即进行熔断降级。 实现单机下的高并发吞吐量 写入数据：页面缓存技术 + 磁盘顺序写 读取数据：零拷贝技术 简单看一下零拷贝技术和非零拷贝技术的区别 零拷贝技术： 非零拷贝技术： 可以看出区别在于非零拷贝技术直接将数据传给网卡进行发送，少了一次拷贝到socket接口的操作。","link":"2024/09/26/Kafka%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%90%86/"},{"title":"Mysql知识点","text":"这一章将会讲解mysql相关的知识点。 基础知识 四种基本语句 DDL（Data Definition Languages）语句：即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，常用的语句关键字有：CREATE、ALTER、DROP、TRUNCATE、COMMENT。增删改表的结构。 DML（Data Manipulation Language）语句：即数据操纵语句，用来查询、添加、更新、删除等，常用的语句关键字有：SELECT、INSERT、UPDATE、DELETE、MERGE、CALL、EXPLAIN PLAN、LOCK TABLE，包括通用性的增删改查。增删改表的数据。 DCL（Data Control Language）语句：即数据控制语句，用于授权/撤销数据库及其字段的权限。常用的语句关键字有：GRANT、REVOKE。 TCL（Transaction Control Language）语句：事务控制语句，用于控制事务，常用的语句关键字有：COMMIT、ROLLBACK、SAVEPOINT、SET TRANSACTION。 数据结构","link":"2024/09/26/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"title":"ThreadLocal源码解析","text":"最近在整理ThreadLocal，打算把这方面的内容好好理一理。 概述 ThreadLocal 是一个线程的本地变量，这个变量是线程独有，且不能与其他线程共享的。 我们都知道线程是处理器调度的基本单位，而进程是资源调度的基本单位。在高并发情况下如果线程频繁去访问内存资源极容易造成线程冲突，而且有些线程工作需要线程去维护一个临时变量，ThreadLocal就是每个线程都有一个资源副本，是不需要加锁的。 可以这样去理解： 锁是通过时间换空间的做法。 ThreadLocal是通过空间换时间的做法 源码解析 set方法 123456789101112131415/** * 若map为空，则创建ThreadLocalMap */public void set(T value) { Thread t = Thread.currentThread(); //获取当前前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) { //调用ThreadLocalMap的set方法 map.set(this, value); } else { createMap(t, value); }} 我们可以看到ThreadLocalMap对象只有在第一次调用时才会通过createMap方法初始化。 我们先看一下createMap方法，ThreadLocalMap的set方法稍后再看。createMap是ThreadLocal里的方法,他需要传入当前线程和新值 123void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue);} 我们可以看到，这里new出来的ThreadLocalMap赋值给Thread对象里的threadLocals变量，从这里可以看出ThreadLocalMap是当前线程Thread的一个全局变量。同时它在初始化ThreadLocalMap时还传入了一个this指针，这个指针就是ThreadLocal对象。 接下来我们看看ThreadLocalMap的初始化函数 12345678ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) { //INITIAL_CAPACITY = 16 table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);} 我们可以看到这里ThreadLocalMap初始化的基本流程： 初始化ThreadLocalMap里的Entry类型的数组变量table 计算firstKey的hashCode，用坐数组下标 这里我们注意firstKey时刻指代的是ThreadLocal对象,计算下标时是通过hashCode和的(INITIAL_CAPACITY - 1)与运算 给table[i]赋值 初始化size 设置table阈值 我们再来看看ThreadLocalMap的set(this,value)方法 123456789101112131415161718192021222324252627282930313233343536private void set(ThreadLocal&lt;?&gt; key, Object value) { // 这里的tab是table的一个弱引用 Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); /** * 这里判读e!=null就很灵性了，说明循环退出条件是一直往数组下一个index查找，直到下一个index对应的元素为null；（这个不就是我们的开放地址法） * * 这里遍历的逻辑是，先通过hash找到数组下标，然后寻找相等的ThreadLocal对象，找不到就往下一个index找。 */ for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal&lt;?&gt; k = e.get(); //找到了相同key的ThreadLocal对象，然后更新value值，退出； if (k == key) { e.value = value; return; } //找到了数组中的一个元素Entry，但是key=null，说明虚引用是可被GC回收的状态，赋值完后，整理内存后退出； if (k == null) { replaceStaleEntry(key, value, i); return; } } //此时tab[i]值为null 可以赋值 tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) /** 对table数组和元素进行整理操作，超过阈值rehash*/ rehash();} 总结一下上述的关系，当我梦创建一个ThreadLocal对象并调用set方法时，这个对象才会去查找当前线程是否包含ThreadLocalMap对象（变量threadLocals,可以理解为Threadlocal对象到value到映射）,没有则创建。在ThreadLocalMap对象里包含了一个Entry[]数组，在数组上面查找返回值。（底层是利用数组构建hash表，解决冲突使用开放地址法。 nextIndex和prevIndex 接下来，我们再细看一下其中涉及到的方法，首先是移动地址i的方法 1234567private static int nextIndex(int i, int len) { return ((i + 1 &lt; len) ? i + 1 : 0);}private static int prevIndex(int i, int len) { return ((i - 1 &gt;= 0) ? i - 1 : len - 1);} 分析代码可得，当i超过len时，会访问下标0,也就是说这是循环查找（开饭地址法嘛）。 replaceStaleEntry 当这个已存在的Entry元素key==null的时候，逻辑上就走到——replaceStaleEntry(key, value, i)，该方法是用来替换“陈旧的”Entry的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) { Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; /** * 从过期key的位置用preIndex向前查找 * 并标记在staleSlot前连续的Entry中第一个过期的key为stolToExpunge */ for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; /** * 从过期key的位置用newIndex向后查找 */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); if (k == key) { /** * 从staleSlot后的位置找到一个与key值相同的Entry * 根据开放地址法可知，我们应该清除掉后面的(key,.),把新值到前面的key中 */ e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // 若相等，说明在staleSlot前面找不到失效的key,直接清理i处的slot，退出即可 if (slotToExpunge == staleSlot) slotToExpunge = i; //这里优先清理掉是staleSlot前的过期key cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; } /** * 从staleSlot后的位置找到一个与key过期的Entry 且在staleSlot前没有找到一个过期key,才会赋值slotToExpunge 为 i * 到这我们可以发现若要slotToExpunge = i,必须有slotToExpunge == staleSlot * 从这里可以看出优先清理staleSlot位置前过期的key */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; } // 上面循环结束说明后面没有相同的key值需要清理，可直接在staleSlot上赋值 tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) //此时说明找到了一个待清除掉slotToExpunge位置，且优先清理靠前的位置。 cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);} 在分析上述代码后，我们可知replaceStaleEntry总共做了两件事情： 在过期的key的位置附上新值，（但是在赋值前一定会向后检测是否存在相同key的值，若有一定要清楚掉） 去找在staleSlot里连续的Entry里第一个过期的Endtry的位置，并把它传入expungeStaleEntry（注意这个位置肯定是我们填完新（key,value）后的位置）。 这里给出一张replaceStaleEntry等图示，注意理解连续的Entry的概念 这里有个问题，为啥一定要找连续的Entry里第一个过期的Endtry的位置，我们可以看看expungeStaleEntry方法和cleanSomeSlots方法 expungeStaleEntry 1234567891011121314151617181920212223242526272829303132333435363738private int expungeStaleEntry(int staleSlot) { Entry[] tab = table; int len = tab.length; /** 清除staleSlot槽位对应的对象引用 */ tab[staleSlot].value = null; tab[staleSlot] = null; size--; /** 数组中元素总数减1 */ Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) { ThreadLocal&lt;?&gt; k = e.get(); /** 如果key==null，则清除掉对应槽位的元素，并且size减1 */ if (k == null) { e.value = null; tab[i] = null; size--; } else { /** * 这里主要的作用是由于采用了开放地址法，所以删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，可以简单理解 * 就是让后面的元素往前面移动。 */ int h = k.threadLocalHashCode &amp; (len - 1); // 应该坐：h 但是我坐在了：i if (h != i) { // 表示k现在所在的位置i并不是它应该在的位置h上。而是由于开放地址法，放到了别的位置上 tab[i] = null; //找到h所在的位置，若tab[h] == null,说明h在前面被清除的位置，直接存值 while (tab[h] != null) { // 说明hash是有冲突的，那么往后找空的位置 h = nextIndex(h, len); } tab[h] = e; } } } //此时在staleSlot和i之间已经没有过期的key,i后面的都是null return i;} 现在我们可以理解为什么要去找最连续entry里第一个过期key了： 根据开放地址法，当我们扫到null时会停止扫描，而当我们扫到过期key时会清理掉该key，为了防止后面的key扫描不到，因此我们应该整理从连续entry里第一个过期key开始整理，遇到一个过期key便删除，同时重新计算后面的每个元素并排序。 cleanSomeSlots 1234567891011121314151617// 初始状态n=lengthprivate boolean cleanSomeSlots(int i, int n) { boolean removed = false; Entry[] tab = table; int len = tab.length; do { i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) { //遇到过期键则删除 n = len; removed = true; i = expungeStaleEntry(i); // 从位置i开始清除Stale元素，并在这个过程中&quot;整理&quot;元素到趋近正确的位置，直到遍历到null的Slot } } while ( (n &gt;&gt;&gt;= 1) != 0); /** n&gt;&gt;&gt;=1相当于n=n/2*/ // i 连续移动log2(len)次，若再每遇到过期键则退出 return removed;} 现在知道为什么这个方法称为cleanSomeSlots,该方法只能保证大部分的陈旧键被删除 可以理解为是对于提升插入速度和table数组内“陈旧”Entry整理耗时的一种平衡处理方案 rehash 12345678private void rehash() { expungeStaleEntries(); /** 清除表中的所有陈旧条目 */ // Use lower threshold for doubling to avoid hysteresis（使用较低的加倍阈值以避免滞后） if (size &gt;= threshold - threshold / 4) { resize(); /** 扩容操作 */ }} 超过table的3/4则扩容。 expungeStaleEntries 遍历table数组里的Entry，调用expungeStaleEntry方法，这里就不粘源码了。 resize 1234567891011121314151617181920212223242526272829303132private void resize() { Entry[] oldTab = table; int oldLen = oldTab.length; /** 将原数组大小扩容2倍 */ int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) { Entry e = oldTab[j]; if (e != null) { ThreadLocal&lt;?&gt; k = e.get(); if (k == null) { e.value = null; // Help the GC } else { /**计算旧的Entry在新的table数组中的位置h */ int h = k.threadLocalHashCode &amp; (newLen - 1); /** * 如果位置h已经被别的Entry占据了，那么就向后查找空位，直到找到为止 */ while (newTab[h] != null) { h = nextIndex(h, newLen); } newTab[h] = e; count++; } } } /** 因为使用了新的数组，所以设置一下新的table数组的阈值 */ setThreshold(newLen); size = count; table = newTab;} 简单来说就是创建新数组，遍历旧数组的每一个值，计算新的hashCode，赋值。 get ThreadLocal中get方法就相对简单很多。我们对照源码进行依次解读 12345678910111213public T get() { Thread t = Thread.currentThread();// 获取当前线程 ThreadLocalMap map = getMap(t);//获取ThreadLocalMap对象 if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; } } return setInitialValue();} 这里是相似的业务逻辑，若果存在map，则查找对应的entry并返回结果。 但是如果不存在ThreadLocalMap，setInitialValue会创建一个ThreadLocalMap,并返回一个默认值，默认值为null（这里不具体显示代码了）。 我们看一下ThreadLocalMap类下的getEntry方法： 12345678private Entry getEntry(ThreadLocal&lt;?&gt; key) { int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);} 属于基本的hash数组查找法，但是要注意如果查找的entry为空或者e.get() != key时处理方法： 12345678910111213141516private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) {//根据开放地址查找法，若key!=null向后遍历 ThreadLocal&lt;?&gt; k = e.get(); if (k == key)//查找到相同元素就返回 return e; if (k == null)//key为null说明这是一个过期的key expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null;//若e==null则直接返回null} 内存溢出 通过上面的分析，我们知道 expungeStaleEntry() 方法是帮助垃圾回收的。 get 和set 方法都可能触发清理方法 expungeStaleEntry() 正常情况下，不会存在溢出，但是 如果我们没有调用get和set的时候就会可能面临着内存溢出。养成好习惯不再使用的时候调用remove()，加快垃圾回收，避免内存溢出。退一步说，就算我们没有调用get和set和remove方法，线程结束的时候，也就没有强引用再指向ThreadLocal中的ThreadLocalMap了，这样ThreadLocalMap和里面的元素也会被回收掉。但是有一种危险是，如果线程是线程池的，在线程执行完代码的时候并没有结束，只是归还给线程池，这个时候ThreadLocalMap和里面的元素是不会回收掉的。 最近把java并发编程的知识重新整理了一下，有一部分文档写在飞书上了。内容和图片来自于互联网，有侵删。 这是以前做的一些笔记：Java并发编程","link":"2024/05/29/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"title":"YHJ23","text":"今天读一篇发在FOCS上的论文 Attribute-Based Encryption for Circuits of Unbounded Depth from Lattices 文章很长，先从方法论下手，浅读一下方法，细节部分日后再补充。 研究背景 目前主流的基于格的ABE芳芳如GVW13,BGG+14等，所能够容纳的电路深度都是有限的，同时它们的组件（主公钥，主私钥，和密文）在最大电路中具有多项式大小深度。（这句话读起来有些费解，我的理解是，例如深度为2，则有22=42^2=422=4个辅助电路加密的公钥或者说对应的密文，而计算密钥时计算深度也会达到2）。为了消除基于格的ABE对电路深度的依赖，作者提出了一种新的方案 研究成果 作者提出构造一个1-key ABE所用到的密码学原语有 laconic function evaluation (LFE) 1-key functional encryption (FE) reusable garbling schemes. 作者构造了一系列上述原语的方案，同时还基于evasive circular LWE assumption（一种加强的evasive LWE assumption）实现了一个比较成熟的ABE方案。 预备知识 再了解整个方案之前，我们先看一下所用到的组件 Circular Evasive LWE 我们先从evasive LWE开始，如下为evasive LWE假设的内容，为了方便理解后面的Circular Evasive LWE,B,A‾′B,\\overline{A}^{\\prime}B,A′采用了相同的分布，两个变量在这里是一样的。 if (1): B,A‾′,P,r⊤B⏟,r⊤⏟A‾′,r⊤P⏟\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{B}}, \\underbrace{\\mathbf{r}^{\\top}} \\overline{\\mathbf{A}}^{\\prime}, \\underbrace{\\mathbf{r}^{\\top} \\mathbf{P}}B,A′,P,r⊤B​,r⊤​A′,r⊤P​, aux ≈\\approx≈ (2): B,A‾′,P,$,$,$\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\$B,A′,P,$,$,$, aux, then (3): B,A‾′,P,r⊤B,r⊤A‾′,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\mathbf{r}^{\\top} \\mathbf{B}, \\mathbf{r}^{\\top} \\overline{\\mathbf{A}}^{\\prime}, \\quad \\mathbf{K}B,A′,P,r⊤B,r⊤A′,K, aux ≈\\approx≈ (4): B,A‾′,P,$,$,K\\mathbf{B}, \\overline{\\mathbf{A}}^{\\prime}, \\mathbf{P}, \\quad \\$, \\quad \\$, \\quad \\mathbf{K}B,A′,P,$,$,K, aux. 其中B←$Zqn×m\\mathbf{B}\\stackrel{\\$}{\\leftarrow} \\mathbb{Z}_q^{n \\times m}B←$Zqn×m​, m=Θ(nlog⁡p)m=\\Theta(n \\log p)m=Θ(nlogp), K←$B−1(P)\\mathbf{K} \\stackrel{\\$}{\\leftarrow} \\mathbf{B}^{-1}(\\mathbf{P})K←$B−1(P), K\\mathbf{K}K是一个低范数矩阵满足BK=P\\mathbf{B K}=\\mathbf{P}BK=P。我们可以这么去理解这个假设，只要不给敌手获悉BK=P\\mathbf{B K}=\\mathbf{P}BK=P，给定X\\mathbf{X}X,r⊤B+e\\mathbf{r}^{\\top} \\mathbf{B}+er⊤B+e,r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e,不论X\\mathbf{X}X为何种分布，r⊤X+e\\mathbf{r}^{\\top} \\mathbf{X}+er⊤X+e均为伪随机性的。 circular evasive LWE假设如下， if (1), Afhe ,S,Acirc ,s⊤(Acirc −S⊗G)≈(2),$,$,Acirc ,$, then (3), Afhe ,S,Acirr ,s⊤(Acirc −S⊗G)≈ (4), $,$,Acirc , \\begin{aligned} &amp;\\text { if (1), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {circ }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx(2), \\$, \\$, \\mathbf{A}_{\\text {circ }}, \\quad \\$ \\text {, } \\\\ &amp; \\text { then (3), } \\mathbf{A}_{\\text {fhe }}, \\mathbf{S}, \\mathbf{A}_{\\text {cirr }}, \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-\\mathbf{S} \\otimes \\mathbf{G}\\right) \\\\ &amp; \\approx \\text { (4), } \\$, \\$, \\mathbf{A}_{\\text {circ }} \\text {, } \\\\ \\end{aligned} ​ if (1), Afhe ​,S,Acirc ​,s⊤(Acirc ​−S⊗G)≈(2),$,$,Acirc ​,$, then (3), Afhe ​,S,Acirr ​,s⊤(Acirc ​−S⊗G)≈ (4), $,$,Acirc ​, ​ 这里暂时认为这个假设是对的，不看这方面的证明。 模数法缩小噪声 我们有如下方法缩减噪声，令MMM为qqq的因子，CCC为一个低深度的电路，如下等式成立： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌋=(s⊤AC, small −C(x)s⊤Gsmall +esmall ⊤) mod qM\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rfloor \\\\ = &amp; \\left(\\mathbf{s}^{\\top} \\mathbf{A}_{C, \\text { small }}-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}+\\mathbf{e}_{\\text {small }}^{\\top}\\right) \\bmod \\frac{q}{M} \\end{aligned}=​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎥⎥⎥​(s⊤AC, small ​−C(x)s⊤Gsmall ​+esmall ⊤​)modMq​​ 经推理可得： ⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM]=(⌊(s⊤AC+elarge ⊤) mod qM⌉−C(x)s⊤Gsmall ) mod qM=Φ(⌊s⊤AC mod qM⌉−C(x)s⊤Gsmall ) mod qM.\\begin{aligned} &amp; \\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right] \\\\ = &amp; \\left(\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top} \\mathbf{A}_C+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} \\\\ \\stackrel{\\Phi}{=} &amp; \\left(\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\mathbf{G}_{\\text {small }}\\right) \\bmod \\frac{q}{M} .\\end{aligned}==Φ​⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎦⎤​⎝⎛​⎣⎢⎢⎢​M(s⊤AC​+elarge ⊤​)modq​⎥⎥⎥⎤​−C(x)s⊤Gsmall ​⎠⎞​modMq​(⌊Ms⊤AC​modq​⌉−C(x)s⊤Gsmall ​)modMq​.​ 为了让第一个等式成立，M为2的指数次放，这样可以使得M/GM/GM/G为整数,让M/GM/GM/G能被规约为GsmallG_{small}Gsmall​。 注意第二个等式是概率成立的，即，当elargee_{large}elarge​没有足够大时，可以使得四舍五入后的值相同。通过规约后再乘以M,可以舍得原式变回模M. M⌊(s⊤(AC−C(x)G)+elarge ⊤) mod qM⌉=(M⌊s⊤AC mod qM⌉−C(x)s⊤⋅MGsmall ) mod q\\begin{aligned} &amp; M\\left\\lfloor\\frac{\\left(\\mathbf{s}^{\\top}\\left(\\mathbf{A}_C-C(\\mathbf{x}) \\mathbf{G}\\right)+\\mathbf{e}_{\\text {large }}^{\\top}\\right) \\bmod q}{M}\\right\\rceil \\\\ = &amp; \\left(M\\left\\lfloor\\frac{\\mathbf{s}^{\\top} \\mathbf{A}_C \\bmod q}{M}\\right\\rceil-C(\\mathbf{x}) \\mathbf{s}^{\\top} \\cdot M \\mathbf{G}_{\\text {small }}\\right) \\bmod q\\end{aligned}=​M⎣⎢⎢⎢​M(s⊤(AC​−C(x)G)+elarge ⊤​)modq​⎥⎥⎥⎤​(M⌊Ms⊤AC​modq​⌉−C(x)s⊤⋅MGsmall ​)modq​ 利用四舍五入可以使得恢复该数恢复到模q。但是这里有个坑，MGsmallMG_{small}MGsmall​只包含较大的2的幂次方，所以还需要设计一种可以恢复G的方法。（这里细节比较多，暂时不讲）解决的大致思路就是把G分为两部分，一部分是可以通过⌊XM⌉M\\left \\lfloor \\frac{X}{M} \\right \\rceil M⌊MX​⌉M复原的部分，和不能通过其复原的部分。 最后我们可以得到函数RemoveNoise(u⊤u^{\\top}u⊤),计算公式如下： vL⊤←u⊤G−1(MGL),vR⊤←u⊤G−1(GR),w⊤←(⌊vL⊤ mod qM⌉,M⌊vR⊤ mod qM⌉)Q,\\begin{array}{l} \\mathbf{v}_{\\mathrm{L}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(M \\mathbf{G}_{\\mathrm{L}}\\right), \\quad \\mathbf{v}_{\\mathrm{R}}^{\\top} \\leftarrow \\mathbf{u}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{G}_{\\mathrm{R}}\\right), \\\\ \\mathbf{w}^{\\top} \\leftarrow\\left(\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{L}}^{\\top} \\bmod q}{M}\\right\\rceil, M\\left\\lfloor\\frac{\\mathbf{v}_{\\mathrm{R}}^{\\top} \\bmod q}{M}\\right\\rceil\\right) \\mathbf{Q}, \\end{array} vL⊤​←u⊤G−1(MGL​),vR⊤​←u⊤G−1(GR​),w⊤←(⌊MvL⊤​modq​⌉,M⌊MvR⊤​modq​⌉)Q,​ 这里的Q是什么暂且不深入讲解。 我们定义一个函数RndPad满足： RndPadA(s)=RemoveNoise(s⊤A+e)=s⊤ARndPad_{A}(s)=RemoveNoise(s^{\\top}A+e)=s^{\\top}ARndPadA​(s)=RemoveNoise(s⊤A+e)=s⊤A bootstrapping 接下来是文章中最重要的阶段，我们定义一个 S=(A‾fhe r⊤A‾fhe +efhe ⊤)(R1,…,R(n+1)⌈log⁡2q⌉)−bits⁡(s)⊗G∈Zq(n+1)×m(n+1)⌈log⁡2q⌉ \\begin{array}{l} \\mathbf{S}=\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}}\\left(\\mathbf{R}_{1}, \\ldots, \\mathbf{R}_{(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}\\right) \\\\ -\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G} \\in \\mathbb{Z}_{q}^{(n+1) \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil} \\end{array} S=(r⊤Afhe ​+efhe ⊤​Afhe ​​)(R1​,…,R(n+1)⌈log2​q⌉​)−bits(s)⊗G∈Zq(n+1)×m(n+1)⌈log2​q⌉​​ A‾fhe ,R\\overline{\\mathbf{A}}_{\\text {fhe }},RAfhe ​,R均可以理解为随机矩阵。 我们定义循环编码为： s⊤(Acirc −(1,bit(S))⊗G)+ecirc \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1,\\text{bit}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{circ}} s⊤(Acirc ​−(1,bit(S))⊗G)+ecirc​ 则对于该循环编码，存在 EvalRndPad(Acirc ,A)=HARdPad EvalRndPadS(Acirc ,A,S)=HA,SRdPad \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}) = \\mathbf{H}_{\\mathbf{A}}^{\\text {RdPad }}\\\\ \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} EvalRndPad(Acirc ​,A)=HARdPad ​EvalRndPadS(Acirc ​,A,S)=HA,SRdPad ​ 满足： s⊤(Acirc −(1,bits⁡(S))⊗G)HA,SRdPad =s⊤Acirc HARndPad −RndPad⁡A(s)+efhe ⊤RRndPad A\\begin{aligned} &amp; \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right) \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }} \\\\ = &amp; \\mathbf{s}^{\\top} \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}}^{\\text {RndPad }}-\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})+\\mathbf{e}_{\\text {fhe }}^{\\top} \\mathbf{R}_{\\text {RndPad }_{\\mathbf{A}}} \\end{aligned} =​s⊤(Acirc ​−(1,bits(S))⊗G)HA,SRdPad ​s⊤Acirc ​HARndPad ​−RndPadA​(s)+efhe ⊤​RRndPad A​​​ 实际上，通过，观察我们可以发现这里将(1,bits⁡(S))(1, \\operatorname{bits}(\\mathbf{S}))(1,bits(S))转化成RndPad⁡A(s)\\operatorname{RndPad}_{\\mathbf{A}}(\\mathbf{s})RndPadA​(s),实际上是做了一个RemoveNoise的运算电路， Unbounded Homomorphic Evaluation 这部分运算同EvalC,和EvalCX一样分别分为两部分UEvalC和UEvalX（详见BGG+14）,我们可以这样直观的理解： EvalC/UEvalC: 发声于密钥生成阶段，电路C可以是任意的，属于一种明文态的同态计算。 EvalCX/UEvalCX: 发声于解密阶段，若想要正确解密，电路C必须满足C(x)=1C(x)=1C(x)=1，属于一种密文态的同态计算。 我们来看在论文中的描述： UEvalC UEvalC(Aattr ,Acirc ,C)\\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)UEvalC(Aattr ​,Acirc ​,C) takes as input Aattr ∈Zq(n+1)×(L+1)m,Acirc ∈Zq(n+1)×(LS+1)m\\mathbf{A}_{\\text {attr }} \\in \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\quad \\mathbf{A}_{\\text {circ }} \\in \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m} Aattr ​∈Zq(n+1)×(L+1)m​,Acirc ​∈Zq(n+1)×(LS​+1)m​ and a circuit C:{0,1}L→{0,1}1×L′C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}^{1 \\times L^{\\prime}}C:{0,1}L→{0,1}1×L′ of arbitrary size and depth, where LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^{2}\\left\\lceil\\log _{2} q\\right\\rceil^{2}LS​=m(n+1)2⌈log2​q⌉2. 这里给出了UEvalC的基本算法，注意一下不论是Aattr\\mathbf{A}_{\\text {attr}}Aattr​还是Acirc\\mathbf{A}_{\\text {circ}}Acirc​都是用于构造电路的算法的。先令Aattr=(A0,A1,…,AL)\\mathbf{A}_{\\text {attr}}=\\left (\\mathbf{A}_{0},\\mathbf{A}_{1},\\dots,\\mathbf{A}_{L} \\right )Aattr​=(A0​,A1​,…,AL​), 我们可以先用Acirc\\mathbf{A}_{\\text {circ}}Acirc​做传统的电路运算 HCi′←EvalC⁡((A0,Ai′,Ai′′), gate Ci as one-gate circuit ),Ai′←(A0,Ai′,Ai′′)HCi′\\begin{array}{l} \\mathbf{H}_{C_{i}}^{\\prime} \\leftarrow \\operatorname{EvalC}\\binom{\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right),}{\\text { gate } C_{i} \\text { as one-gate circuit }}, \\\\ \\mathbf{A}_{i}^{\\prime} \\leftarrow\\left(\\mathbf{A}_{0}, \\mathbf{A}_{i^{\\prime}}, \\mathbf{A}_{i^{\\prime \\prime}}\\right) \\mathbf{H}_{C_{i}}^{\\prime} \\\\ \\end{array} HCi​′​←EvalC( gate Ci​ as one-gate circuit (A0​,Ai′​,Ai′′​),​),Ai′​←(A0​,Ai′​,Ai′′​)HCi​′​​ 最后根据上面的运算结果，即： HAi′RndPad←EvalRndPad(Acirc ,Ai′),Ai←Acirc HAi′RndPad\\begin{array}{l} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}} \\leftarrow \\text{EvalRndPad}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{i}^{\\prime}), \\\\ \\mathbf{A}_{i} \\leftarrow \\mathbf{A}_{\\text {circ }} \\mathbf{H}_{\\mathbf{A}_{i}^{\\prime}}^{\\text{RndPad}}\\\\ \\end{array} HAi′​RndPad​←EvalRndPad(Acirc ​,Ai′​),Ai​←Acirc ​HAi′​RndPad​​ 这里摘自于原论文，个人感觉符号使用有点混乱了 UEvalCX 这里就是同理了，不再过多赘述，如果在密态情况下EvalCX,计算出来的是形如： AwithLargeNoise′=s⊤(AC−C(x)⊗G)+elarge \\mathbf{A}_{\\text{withLargeNoise}}^{\\prime}=\\mathbf{s}^{\\top}\\left(\\mathbf{A}_{C}-C(x) \\otimes \\mathbf{G}\\right) + \\mathbf{e}_{\\text{large}} AwithLargeNoise′​=s⊤(AC​−C(x)⊗G)+elarge​ 但是在计算 EvalRndPadS(Acirc ,AwithLargeNoise′,S)=HA,SRdPad \\text{EvalRndPadS}(\\mathbf{A}_{\\text {circ }},\\mathbf{A}_{\\text{withLargeNoise}}^{\\prime},\\mathbf{S}) = \\mathbf{H}_{\\mathbf{A}, \\mathbf{S}}^{\\text {RdPad }}EvalRndPadS(Acirc ​,AwithLargeNoise′​,S)=HA,SRdPad ​ 中，由于用了循环编码EvalRndPadS可以计算出与EvalRndPad相同的值。 方案 先来看看方案的原算法吧，为了更好的理解以下摘自于原文，我会附上相关的自己的理解 Setup (1L)\\left(1^L\\right)(1L) defines appropriate n,m,q,σ,σ′,σ−1n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1}n,m,q,σ,σ′,σ−1​, σpost \\sigma_{\\text {post }}σpost ​ as described at the end of Section 3, and sets LS=m(n+1)2⌈log⁡2q⌉2L_{\\mathbf{S}}=m(n+1)^2\\left\\lceil\\log _2 q\\right\\rceil^2LS​=m(n+1)2⌈log2​q⌉2. The algorithm samples: Aattr ←Zq(n+1)×(L+1)m,Acirc ←Zq(n+1)×(LS+1)m,(B,τ)←TrapGen⁡(1n,1m,q),z←Zqn\\begin{aligned} \\mathbf{A}_{\\text {attr }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times(L+1) m}, \\\\ \\mathbf{A}_{\\text {circ }} &amp; \\leftarrow \\mathbb{Z}_{q}^{(n+1) \\times\\left(L_{\\mathbf{S}}+1\\right) m}, \\\\ (\\mathbf{B}, \\tau) &amp; \\leftarrow \\operatorname{TrapGen}\\left(1^{n}, 1^{m}, q\\right), \\quad \\mathbf{z} \\leftarrow \\mathbb{Z}_{q}^{n} \\end{aligned} Aattr ​Acirc ​(B,τ)​←Zq(n+1)×(L+1)m​,←Zq(n+1)×(LS​+1)m​,←TrapGen(1n,1m,q),z←Zqn​​ It outputs mpk=(n,m,q,σ,σ′,σ−1,σpost ,Aatt ,Acirc ,B,z),msk=(mpkτ)\\mathrm{mpk}=\\binom{n, m, q, \\sigma, \\sigma^{\\prime}, \\sigma_{-1},}{\\sigma_{\\text {post }}, \\mathbf{A}_{\\text {att }}, \\mathbf{A}_{\\text {circ }}, \\mathbf{B}, \\mathbf{z}}, \\mathrm{msk}=\\binom{\\mathrm{mpk}}{\\tau}mpk=(σpost ​,Aatt ​,Acirc ​,B,zn,m,q,σ,σ′,σ−1​,​),msk=(τmpk​). 启动阶段，生成陷门和循环电路参数以及属性参数。 KeyGen(msk,C)(msk, C)(msk,C) takes msk,C:{0,1}L→{0,1}msk, C:\\{0,1\\}^{L} \\rightarrow\\{0,1\\}msk,C:{0,1}L→{0,1} as input. It computes AC←UEvalC(Aattr ,Acirc ,C)\\mathbf{A}_{C} \\leftarrow \\mathrm{UEvalC}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{A}_{\\text {circ }}, C\\right)AC​←UEvalC(Aattr ​,Acirc ​,C) and samples z′←Zqn+1\\mathbf{z}^{\\prime} \\leftarrow \\mathbb{Z}_{q}^{n+1}z′←Zqn+1​. The algorithm generates a trapdoor k←$SimplD(B,τ,A‾CG−1(z′)+z,σ−1),k \\stackrel{\\$}{\\leftarrow} \\text{SimplD}(\\mathbf{B},\\tau,\\overline{\\mathbf{A}}_{C}G^{-1}(z')+z,\\sigma_{-1}), k←$SimplD(B,τ,AC​G−1(z′)+z,σ−1​), whereA‾C∈Zqn×m\\overline{\\mathbf{A}}_{C} \\in \\mathbb{Z}_{q}^{n \\times m}AC​∈Zqn×m​ is the the first nnn rows of AC\\mathbf{A}_{C}AC​. The algorithm outputs skC=(z′,k)\\mathrm{sk}_{C}=\\left(\\mathbf{z}^{\\prime}, \\mathbf{k}\\right)skC​=(z′,k). 这里做了UEvalC计算，并且运用了陷门，生成密钥，若想要解密，必须生成相同的值 可以理解为用陷门对ACA_{C}AC​进行了一次签名，只不过这种签名是密态的。 Enc (mpk,x,μ)(\\mathrm{mpk}, \\mathbf{x}, \\mu)(mpk,x,μ) takes mpk,x∈{0,1}L,μ∈{0,1}mpk, \\mathbf{x} \\in\\{0,1\\}^{L}, \\mu \\in\\{0,1\\}mpk,x∈{0,1}L,μ∈{0,1} as input. It samples r←DZ,σ,≤σλn\\mathbf{r} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{n}r←DZ,σ,≤σλ​n​ and sets s←(r⊤,−1)⊤\\mathbf{s} \\leftarrow\\left(\\mathbf{r}^{\\top},-1\\right)^{\\top}s←(r⊤,−1)⊤. The algorithm creates a circular encryption by A‾fhe ←&amp;Zqn×m,efhe ←&amp;DZ,σ,≤σλmR←${0,1}m×m(n+1)⌈log⁡2q⌉,Afhe ←(A‾fhe r⊤A‾fhe +efhe ⊤), S←Afhe R−bits⁡(s)⊗G,\\begin{array}{l} \\overline{\\mathbf{A}}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathbb{Z}_{q}^{n \\times m}, \\quad \\mathbf{e}_{\\text {fhe }} \\stackrel{\\&amp;}{\\leftarrow} \\mathcal{D}_{\\mathbb{Z}, \\sigma, \\leq \\sigma \\sqrt{\\lambda}}^{m}\\\\ \\mathbf{R} \\stackrel{\\$}{\\leftarrow}\\{0,1\\}^{m \\times m(n+1)\\left\\lceil\\log _{2} q\\right\\rceil}, \\\\ \\mathbf{A}_{\\text {fhe }} \\leftarrow\\binom{\\overline{\\mathbf{A}}_{\\text {fhe }}}{\\mathbf{r}^{\\top} \\overline{\\mathbf{A}}_{\\text {fhe }}+\\mathbf{e}_{\\text {fhe }}^{\\top}} \\text {, } \\\\ \\mathbf{S} \\leftarrow \\mathbf{A}_{\\text {fhe }} \\mathbf{R}-\\operatorname{bits}(\\mathbf{s}) \\otimes \\mathbf{G}, \\\\ \\end{array} Afhe ​←&amp;Zqn×m​,efhe ​←&amp;DZ,σ,≤σλ​m​R←${0,1}m×m(n+1)⌈log2​q⌉,Afhe ​←(r⊤Afhe ​+efhe ⊤​Afhe ​​), S←Afhe ​R−bits(s)⊗G,​ than encoding by eattr ←DZ,σ′,≤σ′λ(L+1)m,ecirc ←DZ,σ′,≤σ′λ(Ls+1)m,cattr ⊤←s⊤(Aattr −(1,x⊤)⊗G)+eattr ⊤,ccirc ⊤←s⊤(Acirc −(1,bits⁡(S))⊗G)+ecirc ⊤.\\begin{array}{l} \\mathbf{e}_{\\text {attr }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L+1) m}, \\quad \\mathbf{e}_{\\text {circ }} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}}^{(L \\mathbf{s}+1)m}, \\\\ \\mathbf{c}_{\\text {attr }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {attr }}-\\left(1, \\mathbf{x}^{\\top}\\right) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {attr }}^{\\top}, \\\\ \\mathbf{c}_{\\text {circ }}^{\\top} \\leftarrow \\mathbf{s}^{\\top}\\left(\\mathbf{A}_{\\text {circ }}-(1, \\operatorname{bits}(\\mathbf{S})) \\otimes \\mathbf{G}\\right)+\\mathbf{e}_{\\text {circ }}^{\\top} . \\end{array} eattr ​←DZ,σ′,≤σ′λ​(L+1)m​,ecirc ​←DZ,σ′,≤σ′λ​(Ls+1)m​,cattr ⊤​←s⊤(Aattr ​−(1,x⊤)⊗G)+eattr ⊤​,ccirc ⊤​←s⊤(Acirc ​−(1,bits(S))⊗G)+ecirc ⊤​.​ It also generates the message encoding as eB←DZ,σpost ,≤σpost λm,emsg←DZ,σ′,≤σ′λcB⊤←r⊤B+eB⊤,cmsg←r⊤z+emsg+μ⋅⌊q/2⌉.\\begin{aligned} \\mathbf{e}_{\\mathrm{B}} &amp; \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma_{\\text {post }}, \\leq \\sigma_{\\text {post }} \\sqrt{\\lambda}}^{m}, \\quad e_{\\mathrm{msg}} \\leftarrow \\mathcal{D}_{\\mathbb{Z}, \\sigma^{\\prime}, \\leq \\sigma^{\\prime} \\sqrt{\\lambda}} \\\\ \\mathbf{c}_{\\mathrm{B}}^{\\top} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{B}+\\mathbf{e}_{\\mathrm{B}}^{\\top}, \\\\ c_{\\mathrm{msg}} &amp; \\leftarrow \\mathbf{r}^{\\top} \\mathbf{z}+e_{\\mathrm{msg}}+\\mu \\cdot\\lfloor q / 2\\rceil . \\end{aligned} eB​cB⊤​cmsg​​←DZ,σpost ​,≤σpost ​λ​m​,emsg​←DZ,σ′,≤σ′λ​​←r⊤B+eB⊤​,←r⊤z+emsg​+μ⋅⌊q/2⌉.​ The algorithm outputs ctx=(S,cattr,ccirc,cB,cmsg)ctx = (S, c_{attr}, c_{circ}, c_{B}, c_{msg})ctx=(S,cattr​,ccirc​,cB​,cmsg​). 与BGG+14不同的是生成了一个循环编码的密文。 Dec (A‾Ca‾C⊤)=AC←UEvalC⁡(Aatr ,Acirc ,C),cC,x⊤←UEvalCX⁡(Aattr ,cattr ⊤,Acirc ccirc ⊤,C,x,S),c′←cmsg+cC,x⊤G−1(z′)−(cB⊤k−a‾C⊤G−1(z′)).\\begin{aligned} \\binom{\\overline{\\mathbf{A}}_{C}}{\\underline{\\mathbf{a}}_{C}^{\\top}} &amp; =\\mathbf{A}_{C} \\leftarrow \\operatorname{UEvalC}\\left(\\mathbf{A}_{\\text {atr }}, \\mathbf{A}_{\\text {circ }}, C\\right), \\\\ \\mathbf{c}_{C, \\mathbf{x}}^{\\top} &amp; \\leftarrow \\operatorname{UEvalCX}\\left(\\mathbf{A}_{\\text {attr }}, \\mathbf{c}_{\\text {attr }}^{\\top}, \\mathbf{A}_{\\text {circ }} \\mathbf{c}_{\\text {circ }}^{\\top}, C, \\mathbf{x}, \\mathbf{S}\\right), \\\\ c^{\\prime} &amp; \\leftarrow c_{\\mathrm{msg}}+\\mathbf{c}_{C, \\mathbf{x}}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)-\\left(\\mathbf{c}_{\\mathrm{B}}^{\\top} \\mathbf{k}-\\underline{\\mathbf{a}}_{C}^{\\top} \\mathbf{G}^{-1}\\left(\\mathbf{z}^{\\prime}\\right)\\right) . \\end{aligned} (a​C⊤​AC​​)cC,x⊤​c′​=AC​←UEvalC(Aatr ​,Acirc ​,C),←UEvalCX(Aattr ​,cattr ⊤​,Acirc ​ccirc ⊤​,C,x,S),←cmsg​+cC,x⊤​G−1(z′)−(cB⊤​k−a​C⊤​G−1(z′)).​ 最后我们对上文所有组件的分析，由与在密态下计算一个UEvalCX可以消除掉在属性电路CCC生成的噪声，因此最后的噪声与CCC无关，仅与removeNoise电路编码的生成的噪声有关，但是removeNoise是一个固定值，所以实现了一个电路无界的功能。","link":"2024/05/28/YHJ23/"},{"title":"Redis概述","text":"本篇文章会讲述Redis的基本知识点。 Redis基础数据类型及其编码 概述：Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 特性（为啥比较快）： 基于内存 基于Reactor模式开发了一套高效的时间处理器，主是单线程事件循环和 IO 多路复用。 Reactor模式：每当有一个 Event 输入到 Server端时，Service Handler 会将其转发（dispatch）相对应的handler进行处理。（类似于将消息放到了一个队列中，通过异步线程池对其进行消费） Redis内置了多种优化过后的数据类型/结构实现，性能非常高。 Redis基础数据类型要牢记： string list set zset hash 以上是Redis的几种数据结结构。Redis底层实现上面这几种数据类型是靠以下的编码实现的，例如关于string，编码方式给出了如何将这种数据类型转化成01bit串。 encoding常量 底层数据结构 INT long类型整数 EMBSTR embstr编码的简单动态字符串 RAW 简单动态字符串 HT 字典 LINKEDLIST 双向链表 ZIPLIST 压缩列表 INTSET 整数集合 SKIPLIST 跳表和字典 Redis数据结构 现在看一下对象类型和对应的底层编码： String类型 int编码 说白了，就是将数字字符串用Long类型来表示。超过这个范围就使用其他编码 embstr编码 如果value值的长度如果小于40，则使用embstr，它可以保存数字类型和字符类型的值。embstr编码是专门用于保存短字符串的一种优化编码方式（可以从图中看出在embstr里申请的是一块连续空间）。 这种连续分配的空间不利于字符串的修改。应此embstr是只读的。如果我们对其进行修改，其实是先转换成raw，再执行修改命令。所以，修改后embstr就会变为raw编码的字符串对象了。 raw编码 当value值的长度如果大于等于40时，则使用raw编码。 如果将原本保存的整数转换为字符串，那么字符串对象的编码也将从int变为raw。 list类型 ziplist编码 linkedlist编码 set类型 intset编码 hashtable编码 zset类型 像zset类型数据也有压缩列表的实现方式，除此之外也可以用跳表作为底层实现，一个zset同时包含一个字典dict和一个跳跃表zskiplist。 概述：跳表是一个带有层级关系的链表，而且每一层级可以包含多个节点，每一个节点通过指针连接起来。 条表的优点： 内存非密集型，在更改节点方面比较容易。 在做范围查找的时候，跳表比平衡树操作要简单。 从算法实现难度上来比较，跳表比平衡树要简单得多。 由于zset经常需要排序，在插入节点时跳表也更加适合遍历查找列表元素。 hash类型 同理可以使用压缩列表和hashtable编码的实现方式 Redis的持久化 RDB 概述：RDB是Redis用来进行持久化的一种方式，是把当前内存中的数据集快照写入磁盘，对应文件为dump.rdb，也就是 Snapshot 快照（数据库中所有键值对数据）。恢复时是将快照文件直接读到内存里。 分为手工执行RDB和定期执行RDB 手工执行两个命令SAVE和BGSAVE: SAVE命令：会阻塞进程。 BGSAVE命令：会fork一个子进程来生成RDB文件 只要Redis启动时检测到RDB文件的存在，那么就会自动载入RDB文件。加载过程中，会一直处于阻塞状态，直到加载完毕为止。由于AOF文件的更新频率一般比RDB文件的更新频率高，所以，如果服务期开启了AOF持久化功能，那么就优先加载AOF文件。 AOF 概述：Redis的持久化方式之一RDB是通过保存数据库中的键值对来记录数据库的状态。而另一种持久化方式 AOF 则是通过保存Redis服务器所执行的写命令来记录数据库状态。 流程：AOF的持久化分为三步：命令追加 ——&gt; 文件写入 ——&gt; 文件同步，如果打开AOF后，每次执行完一个写命令之后，都会把写命令以请求协议格式保存到 aof_buf缓冲区 的末尾。 AOF同步：将AOF缓冲区的内容加载进磁盘中 AOF重写流程： 简单用人话概括一下： 执行重写，开启子进程开始重写到AOF缓冲区，再此期间的AOF命令也会写到重写缓冲区。（写时复制技术，RDB,AOF都有这种技术） 重写结束后，阻塞进程，用重写缓冲区的内容去覆盖AOF缓冲区（新文件覆盖就文件）。 覆盖结束后开始继续向AOF缓冲区内写内容。 混合持久化 概述： RDB优点是数据恢复速度快，但是快照的频率不好把握。频率太低，丢失的数据就会比较多，频率太高，就会影响性能。 AOF优点是丢失数据少，但是数据恢复不快。 混合持久化工作在 AOF 日志重写过程，当开启了混合持久化时，在 AOF 重写日志时，fork 出来的重写子进程会先将与主线程共享的内存数据以 RDB 方式写入到 AOF 文件，然后主线程处理的操作命令会被记录在重写缓冲区里，重写缓冲区里的增量命令会以 AOF 方式写入到 AOF 文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。 特殊数据类型 先提一嘴，以后有用到再补充细节。 geospatial地理位置 可以用于基于地理位置的业务场景。 hyperloglog预估集合的基数 非精准性的统计计数 bitmap位图 可以利用bitmap指定其二进制位是0或1，来实现类似“是”or“否”的相关操作。它的特点也是占用内存空间特别的小。 Redis主从复制 Redis缓存失效 缓冲穿透 概述：当用户查询数据时，发现Redis中不存在，也就是所谓的缓存没有命中，于是这个数据请求就会打到数据库中。 解决方法： 在redis里维护一个空对象（如果数据库里查询不到） 添加布隆过滤器 缓冲击穿 概述：热点key被高并发查询，在热key过期时，对数据库造成巨大的压力。 解决方案： 设置热点key永不过期 加上互斥锁，只允许一个线程去查询数据库。 缓冲雪崩 概述：缓存集中过期，或者redis宕机 解决方案： 针对Redis宕机这一点：配置Redis集群 熔断限流：通过加锁或队列来控制读写数据库的线程数量 针对集中过期：数据预热或者分散数据过期时间 布隆过滤器 概述： bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。 如图：bloom的重点在于容器的大小和散列函数 缓存淘汰策略 不淘汰：缓存写满直接返回错误消息。 过期数据： ttl:最早过期的先淘汰 lru:淘汰最近最少使用数据 lfu:淘汰使用频次最少数据 全部数据： 随机淘汰 lru lfu 缓存读写策略 Cache Aside Pattern（旁路缓存模式） Cache Aside Pattern中服务端需要同时维系db和cache，并且是以 db的结果为准。 先更新 db 然后直接删除 cache 。 为什么先删除后更新不行： 请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 数据更新 -&gt; 请求 2 往缓冲中写入数据。 Read/Write Through Pattern（读写穿透） 写（Write Through）： 先查cache，cache中不存在，直接更新db。 cache中存在，则先更新cache，然后cache服务自己更新db。 读(Read Through)： 从 cache 中读取数据，读取到就直接返回。 读取不到的话，先从 db 加载，写入到 cache 后返回响应。 Write Behind Pattern（异步缓存写入） Read/Write Through是同步更新cache和db，而Write Behind Pattern则是只更新缓存，不直接更新db，而是改为异步批量的方式来更新db。 Redission 概述： Redisson 是架设在 Redis 基础上的一个 Java驻内存数据网格框架, 充分利用 Redis 键值数据库提供的一系列优势, 基于 Java 使用工具包中常用接口, 为使用者提供了 一系列具有分布式特性的常用工具类。 具体阐述其原理，首先得分析其redis的分布式锁 基于redis的分布式锁 使用Redis的setnx命令进行加锁，当该指令返回1时，说明成功获得锁。 但是这种锁存在两个问题： 超时解锁导致并发：：用户A先获取锁，还未执行完业务代码，此时已经过了超时时间，锁被释放。用户B获取到锁，此时用户A和用户B并发执行业务数据。 锁误删除:：用户A执行完业务代码后，执行释放锁操作，而此时用户A已经被超时释放，锁被用户B持有，此时释放锁，就把用户B的锁误删了。 不能支持redis集群。 而redisson实现了 防死锁 防误删 可重入 自动续期 主要的实现方式有三步： uuid+线程id作为key防止误删除 看门狗机制防止超时并发 redLock支持redis集群 RedLock算法 原理：Redlock算法首先获取当前时间戳T1，然后在N个Redis节点上尝试获取锁，并记录获取锁的节点数M和最小的锁超时时间min_expire_time。如果获取锁的时间cost_time小于锁的超时时间，并且M大于等于Q，则认为锁获取成功，返回锁的value值和锁的超时时间；否则依次在获取锁的节点上释放锁。 看门狗机制 Redisson针对业务还未处理完毕，锁就提前过期这个问题的解决办法：提供一个守护线程，定时检查锁状态。如果锁快要过期了，客户端还占有锁，那么就自动给锁续期，延长锁的过期时间。","link":"2024/09/23/Redis%E6%A6%82%E8%BF%B0/"},{"title":"git指南","text":"git作为最常用的分布式版本控制工具，是企业合作开发比不可少的工具。当你发布的代码出现问题后，大多都是靠git来解决的。目前市面上git的使用方法有很多，本文会总结大部分工作中常用的git命令(对于一些少见的复杂场景下的git应用，这个到时候再查也没问题)，总而言之，如果你的代码出了岔子抑或着捅了什么篓子，git绝对是帮你兜底的亲爸爸般的存在。笔者纯萌新入职，总结一下工作几天的git学习情况 基本原理 首先聊一下git的基本原理： 如图：git分为四个区域 Workspace： 工作区，就是平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器 我们通常开发工作方式，是从主分支创建一条属于自己的分支，在这个分支上完成自己要实现的功能。再将自己的分支提交给远程仓库实现代码合作。而企业开发中，远程仓库是通常分为多种分支，每个分支对应一种环境，例如 测试环境：所有人员提交的分支都会先合并到这个分支中，在这个分支上自动构建项目，来测试功能是否正常运行，测试环境是给开发人员用，用于调试代码，因此包含了很多正在开发的代码修改。 预发布环境：预发布环境是给产品人员用的，如果产品觉得没有问题了，就可以准备正式上线到生产环境。 生产环境：到这一步就是给广大的客户使用的，到这一步，代码合并正式完成，此时的分支通常就是我们所谓的master分支（两条分支内容一样但通常是分开的）。 通常企业会利用工具自动在这些分支上构建项目，程序员要做的就是把自己的分支合并到这些分支上。 一次基本的拉去分支的流程 相信很多同学都用过githubclone代码，这里就不赘述了。通常情况下，我们在企业开发过程中，如果有分配到相关的需求，需要我们自己来在远程创建属于自己的分支（这个过程通常有用相关系统一键式创建，不用自己敲命令）。记得在主分支上执行： 1git pull 拉取最新代码（自己的远程分支），通过 1git checkout [分支名] 来切换到自己的分支并开发最后 12git add # 将文件放入缓存区，我们可以通过 git status 查看是否有未提交的文件git commit -m &quot;hello git&quot; 实现提交，此时用git log查看可以看到字节提交的记录。也许会用同学说，现在使用idea基可以通过图形化工具来解决，跟不需要了解这些命令，作者本人在刚入行的时候也甚是喜欢idea图形化工具，但是idea的图形化工具除了执行git命令外还增加了一些代码审查、提示等其他功能，个人认为如果做为页面展示工具十分不错，但是如果是涉及核心等如merge,reset,cherypick等操作，还是用命令行工具比较方便。 解冲突 马上就来到开发中最常见的情形–发生冲突。冲突一般发生在git merge合并时，当你上传代码到远程并试图合并到测试分支上时，若存在另一个小伙伴，在你改动代码到同一处地方进行修改，且已经合到了测试分支上。由于你们的分支都是从master分支拉取下来的，你们在开发代码时彼此看不到互相的改动，当代码合并时就会发生冲突。 既然知道了冲突是怎么发生的，那么解冲突的位置也就一目了然了。冲突时发生在我们试图将测试分支合并到测试分支上时发生的，那么解决冲突就是在测试分支上解决。 你所创建的开发分支是干净的分支，与master分支的改动仅包含你业务需求的改动。 一般在远程解冲突的过程，企业会通过一些技术手段将发生冲突的地方组装另外的一条冲突分支（分支内容包含你的分支和所有的测试分支），你可以拉取这条冲突分支在本地解完冲突后再将这条分支推送回去，之后就可以删除这条分支了。 我们来看看冲突发生的一般形式： 1234567// &lt;---&gt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;// 主分支上的修改==========// 被合并的分支上的修改&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;// &lt;---&gt; 这个时候你调整代码，把‘&lt;&lt;’,‘==’,‘&gt;&gt;’删除，使代码能够正常运行，就能解决冲突了。 回退版本 在开发过程中,经常会遇到我们难以处理的bug或异常，这个时候就需要回退版本了，我们可以通过 1git reset --hard [版本号] 来回退版本，版本号可以通过git reflog来查看，但是注意，这里是硬回退，一旦回退后，最近的修改就不可见了，如果希望软回退，那么就需要使用命令git reset --soft实现一个软回退，在这种回退使得你仍然能够查看最近的提交。 隐藏修改 在日常开发中，我们可能需要同时处理多个需求，因此一个项目中可能存在多个分支，故而我们需要在多个分支间切换。当为们开发一个分支开发到一半时，常常面临着需要切换到另一条分支去工作的情况，或者说你在错的分支上开发了，需要将这份修改转移到其他地方，而这些修改还未提交。当然你也可以选择先提交的方式再转移分支，但是日常开发中你需要时刻主要你修改了哪些地方，因此不建议直接提交。 我们可以通过 1git stash 来将当前分支的内容隐藏，此时所有的改动都会被暂时存进缓存区。通过git status可以查看我们的分支是干净的–没有修改，在这个时候我们切换分支就是安全的。 1git stash list 我们可以查看暂存的分支，以及是在哪条分支缓存的修改，而 1234567# 还原分支git stash apply # 删除stash缓存git stash drop# 等价于 apply+dropgit stash pop 能将修改提交，甚至提交到其他分支。这样既是我们不小心在错误的分支上开发，也可以将修改转移到正确的分支。","link":"2024/06/29/git%E6%8C%87%E5%8D%97/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"2024/05/27/hello-world/"},{"title":"hexo-Icarus页面优化","text":"记录一次页面调整，简单介绍一下，本人前端小白，style语法基本不懂，关于页面大小问题查询了很多资料。最后调整将大小调整到一个比较满意的程度 页面宽度调整 众所周之hexo初始设置中，内容展示页面过小，两边距离过大，因此文章内容看起来及其不自然。 经过我查阅以下及相关文档： Icarus主题美化 Icarus widget 宽度如何修改？ Hexo博客icarus主题定制篇 Hexo博客主题之Icarus的设置与美化 风月的博客（非常全） 内容总算是明白怎样设置了【痛哭】 有不少大佬改成首页内容为三栏，文章浏览为两栏的模式，但本文仅针对两栏的改写。 调整文章内容页面宽度 步骤一 修改themes/icarus/include/style/base.styl文件为： 123\\\\第26行- $gap ?= 32px+ $gap ?= 32px 这段代码可以减小两边的空白 步骤二 修改themes/icarus/layout/layout.jsx文件为 123\\\\第29行- 'is-8-tablet is-8-desktop is-8-widescreen': columnCount === 2,+ 'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 注意是把第三个8改成9，这段代码代表当采用两栏格式时，会扩大文章内容页面，但是修改过后左右两边会不对称，也就是github上讨论的问题 步骤三 修改themes/icarus/layout/common/widgets.jsx文件为 1234case 2:\\\\第44行- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; 这段代码代表当文章为两栏时，使得widget宽度为3，注意必须使得文章内容长度+widget宽度为12，否则格式会乱 标题调整 我在themes/icarus/include/style/article.styl文件中设置了标题的大小和颜色，具体看风月的博客。 雪花效果 雪花效果 试了试，好像没啥效果，以后再总结 高级用途 强推：hexo写文在必备 hexo入门写作","link":"2024/06/15/hexo-Icarus%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96/"},{"title":"常见漏洞原理","text":"在这篇文章中我会收录一些常见的漏洞及其原理，同时分析抵御该漏洞的相关方法，即能够加强在做研发过程中的安全意识，也能为结合后面学习spring security打下基础。 SQL注入 简介 在输⼊的字符串中注⼊SQL指令，这些注⼊的恶意指令会被数据库服务器误认为是正常的SQL指令⽽允许，系统因此遭到破坏或是⼊侵。 SQL注入主要分为以下几类： • 基于布尔类型的盲注，即可以根据返回⻚⾯判断条件真假的注⼊。 • 基于时间的盲注，即不能根据⻚⾯返回的内容判断任何信息，要⽤条 件语句查看时间延迟语句是否⼰执⾏（即⻚⾯返回时间是否增加）来判 断。 • 基于报错注⼊，即⻚⾯会返回错误信息，或者把注⼊的语句的结果直 接返回到⻚⾯中。 • 联合查询注⼊，在可以使⽤Union 的情况下的注⼊。 • 堆查询注⼊，可以同时执⾏多条语句时的注⼊。 基于布尔类型的盲注 适⽤场景：后端执行sql执⾏的结果不会直接显示在前端，但是会在前端显示正确或者错误。 布尔注入的的原理： 获取数据库名字的⻓度： select length(DATABASE())。 截取字符, 使用 123select MID('string',2,2);select substr('string',2);select left('string',2); 其中substr 和 MID作⽤⼀样，left是从字符串左边截取字符. 3. 为了⽅便遍历，⽤到for循环，适⽤ASCII：ASCII 和 ARD作⽤⼀样 通过以上方法进行枚举，先猜⻓度，再猜每⼀位上的字符，获取库名，表名，列名，数据（字段值）。 也可以使⽤⼆分法去暴⼒枚举，这样更快，例如：⻓度&gt;=8是否成⽴ 基于时间的盲注 适⽤场景：既没有数据回显，也不会在sql语句正确与否时显示不同的内容。(即前端不会显示任何信息) 基于时间的盲注原理：利用判断条件和sql中的sleep方式判断条件是否正确。（可以理解为在数据库端端一种布尔注入，原本前端没有任何显示信息，可以通过反应时间了解正确或错误） 如利用： 123select sleep(if(select length(database())=8),1,0);select if(length(database())=8,sleep(1),0);-- 两者等价 基于报错的注⼊ 这个比较好理解，前端会把后台报错的信息打印出来. extractValue()是一个 XML 处理函数，它从给定的 XML 片段中提取值。通过构造一个不正确的 XML 片段，可以触发一个错误消息，其中包含我们插入的恶意数据。 updatexml() 是一个 XML 更新函数，用于更新给定 XML 片段中的节点。通过构造一个不正确的 XML 更新语句，同样可以触发一个错误消息。 实例如下： 12select extractValue('',concat('-',database()));select updatexml('',concat('-',database()),''); 会分别产生如下报错信息 对于 extractValue()： 1SQL Error (1105): XPATH syntax error: '-'database_name 对于 updatexml()： 1SQL Error (1105): XPATH syntax error: '-'database_name SQL注入的基本流程 判断是否有sql注⼊漏洞,方法如下： 加⼀个单引号’，看是否出错，因为引号必须成对出现，否则会出错（判断是否能注入）。 两次尝试 1=1 正常输出，1=2错误输出，证明SQL语句⽣效，存在SQL注⼊漏洞（判断是否能布尔注入）。 1select first_name,last_name from user where user_id='1'and 1=#'; 获得数据库名,可利用union等类似的联合查询 获得表名 获取列名 获得数据 获取对应元数据的方法依然是采用遍历查找的办法。 防御方法 根源问题：服务端把⽤户输⼊当作命令执⾏ 校验⽤户输⼊参数，过滤连接符 对用户输入转义 数据库异常信息隐藏，将异常进⾏封装，防⽌基于报错的SQL注⼊ 数据库敏感信息加密，⽤MD5哈希的时候，记得加盐 安装web应⽤防⽕墙WAF 将输⼊进⾏参数化 命令注入漏洞 和sql注入类似，将用户对输入当成shell命令去执行。这里不赘述了 文件上传漏洞 简介 前端⻚⾯需要⽤户上传⽂件的时候，攻击者上传恶意的⽂件，⽐如上传后⻔病毒⽊⻢到⽹站中，⽹站因此遭到破坏或是⼊侵。 防御方法 这里给几个简单的防御手段。 代码层面： 在前后端增加文件校验接口 对文件进行内容二次渲染 重命名文件，将文件隔离出来，访问时只访问文件的路径。 管理层面： 部署WAF防⽕墙 正确配置服务器请求类型(禁⽌使⽤PUT请求⽅法) 及时更新系统、中间件、脚本、数据库、CMS或框架的漏洞补丁(避免解析漏洞) 权限控制层面： 限制上传⽬录下拥有的执⾏权限 XSS跨站脚本攻击 原理：跨站脚本攻击利⽤了⽹站对⽤户输⼊的不正确处理，使得恶意⽤户能够向受害者的⽹⻚中注⼊恶意脚本。这些脚本在⽤户浏览器中执⾏，从⽽ 导致安全⻛险。跨站脚本攻击的主要原理包括： ⽤户输⼊未经过滤或转义：⽹站未正确过滤或转义⽤户输⼊，使得恶意⽤户能够插⼊恶意脚本。 脚本在⽤户浏览器中执⾏：⼀旦恶意脚本被注⼊到受害者的⽹⻚中，它将在⽤户浏览器中执⾏，攻击者可利⽤此执⾏环境进⾏进⼀步攻击。 常见的事发网站：日志，小说，论坛等内容存储网站。 XSS攻击类别 反射型 XSS 反射型 XSS 是最常⻅的 XSS 攻击类型。攻击者构造恶意的 URL，其中包含恶意脚本。当⽤户点击带有恶意参数的 URL 时，服务器将恶意脚本作 为响应的⼀部分返回给⽤户浏览器，并在浏览器中执⾏。 存储型 XSS 存储型 XSS 发⽣在⽹站存储⽤户提交的数据，且未经过滤或转义的情况下直接在⽹⻚中显示。攻击者提交包含恶意脚本的数据，然后其他⽤户在访问包含该数据的⻚⾯时，恶意脚本将在他们的浏览器中执⾏。 DOM型 XSS DOM 型 XSS 是基于⽂档对象模型（Document Object Model，DOM）的⼀种XSS攻击。攻击者构造恶意URL，其中包含恶意脚本。当⽤户点击包含恶意参数的URL时，恶意脚本修改⻚⾯的 DOM 结构，从⽽导致安全漏洞。 利用流程 总体通过四种途径来利用： 输入字段和表单 URL参数 富文本编辑器 防御方法 为了有效防御跨站脚本攻击，以下是⼀些常⻅的防御措施： 输⼊验证和过滤 ⽹站应该对⽤户输⼊的数据进⾏验证和过滤，确保只接受预期的输⼊。例如，可以使⽤⽩名单过滤，只允许特定字符和标记，同时拒绝其他 潜在的恶意脚本。 输出转义 在将⽤户输⼊的数据显示在⽹⻚中时，应该对其进⾏适当的输出转 义，以确保浏览器将其视为纯⽂本⽽不是可执⾏的代码。这样可以防⽌恶 意脚本在⽤户浏览器中执⾏。 设置 HTTP 头部 通过设置适当的 HTTP 头部，可以增强⽹站的安全性。例如，可以使⽤ Content Security Policy（CSP）来限制⻚⾯中允许执⾏的脚本来源，从⽽减少跨站脚本攻击的⻛险。 CSRF跨站请求伪造 原理:攻击者通过伪造⽤户的浏览器的请求，向访问⼀个⽤户⾃⼰曾经认证访问过的⽹站发送出去，使⽬标⽹站接收并误以为是⽤户的真实操作⽽去执⾏命令。常⽤于盗取账号、转账、发送虚假消息等。攻击者利⽤⽹站对请求的验证漏洞⽽实现这样的攻击⾏为，⽹站能够确认请求来源于⽤户的浏览器，却不能验证请求是否源于⽤户的真实意愿下的操作⾏为。 CSRF等攻击流程 用户浏览并登录信任的网站 A，通过用户认证后，会在浏览器中生成针对 A 网站的 Cookie； 用户在没有退出网站 A 的情况下访问网站 B，然后网站 B 向网站 A 发起一个请求； 用户浏览器根据网站 B 的请求，携带 Cookie 访问网站 A； 由于浏览器会自动带上用户的 Cookie，所以网站 A 接收到请求之后会根据用户具备的权限进行访问控制，这样相当于用户本身在访问网站 A，从而网站 B 就达到了模拟用户访问网站 A 的操作过程。 关于CORS 这里我想要提一嘴cors,经常做研发的小伙伴都知道，跨域问题在我们日常开发中特别常见。 由于当下的 Web 应用程序开发基本都采用了前后端分离的开发模式，例如，当我们访问“test.com”前端域名时，在前端中会访问“api.test.com”后端路由获得服务。但是这个请求已经跨越了两个域名，因此浏览器默认会拒绝这种访问。 请注意，跨域是浏览器的一种同源安全策略，是浏览器单方面限制的，所以仅在客户端运行在浏览器中才需要考虑这个问题。 浏览器在 HTTP 请求的消息头部分新增一些字段，如下所示： 123456//浏览器自己设置的请求域名Origin //浏览器告诉服务器请求需要用到哪些 HTTP 方法Access-Control-Request-Method//浏览器告诉服务器请求需要用到哪些 HTTP 消息头Access-Control-Request-Headers 当浏览器进行跨域请求时会和服务器端进行一次的握手协议，从响应结果中可以获取如下信息: 123456//指定哪些客户端的域名允许访问这个资源Access-Control-Allow-Origin //服务器支持的 HTTP 方法Access-Control-Allow-Methods //需要在正式请求中加入的 HTTP 消息头Access-Control-Allow-Headers 综上所述，浏览器在跨域请求时会和服务器通信访问的方法和访问的源域名。而服务器恰好可以设置允许哪些域名可以访问，那么我们就知道如何解决CORS问题了：服务器合理设置这些响应结果中的消息头。 就是我们开发中经常使用的CorsFilter 123config.setAllowedOrigins(Arrays.asList(&quot;*&quot;));config.setAllowedMethods(Arrays.asList(&quot;*&quot;)); 通过这样的配置使得所有请求可以跨域访问。注意这样配置的重点是让浏览器能够将所有其他域的请求转发给服务器，如果要防止CSRF类的攻击，后端还是要对所有请求做校验。 小结一下：CSRF 是一种攻击行为，所以我们需要对系统进行保护，而 CORS 更多的是一种前后端开发模式上的约定。 防御方法 验证 HTTP Referer 字段:根据 HTTP 协议，在 HTTP 头中有⼀个字段叫 Referer，它记录了该 HTTP 请求的来源地址。服务端只需要娇艳请求验证其 Referer 值。 在请求地址中添加 token 并验证:可以在 HTTP 请求中以参数的形式加⼊⼀个随机产⽣的token，并在服务器端建⽴⼀个拦截器来验证这个 token，如果请求中没有token 或者 token 内容不正确，则认为可能是 CSRF 攻击⽽拒绝该请求。 这里补充几个小知识点： 浏览器在Post请求中自动带上cookie的条件（假设请求http://aaa.www.com/xxxxx/list）： 1、domain=域名,或者为其子域名（aaa.www.com 和www.com） 2、仅在 HTTPS 安全通信时才会发送 Cookie 3、path=PATH 注意：每个cookie都存在着domain和path存储cookie来自的域和请求路径。 CSRF token 不会自动被浏览器附带在请求中，需要开发者显式添加。这意味着攻击者不能仅凭 cookie 发起有效请求，因为缺少正确的 token。所以token可以抵御csrf攻击 在 HTTP 头中⾃定义属性并验证: SSRF 服务端请求伪造 SSRF （Server-Side Request Forgery），服务器端请求伪造，是强制服务器发起由攻击者伪造的请求的⼀种安全漏洞。 请求伪造，就是攻击者伪造正常的请求，以达到攻击的⽬的，就是常⻅的Web安全漏洞之⼀。如果“请求伪造”发⽣在服务器端，那么这个漏洞就叫做“服务器端请求伪造”。 漏洞原因 服务端提供了从其他服务器应⽤（也可以是本地）获取数据的功能；服务端对⽤户提供的URL和远端服务器返回的信息没有进⾏合适的验证或者过滤。 漏洞利用流程 当攻击者想要访问服务器B上的服务，但是由于存在防火墙或者服务器B是属于内网主机等原因导致攻击者无法直接访问。如果服务器A存在SSRF漏洞，这时攻击者可以借助服务器A来发起SSRF攻击，通过服务器A向主机B发起请求，达到攻击内网的目的。如图 这里我们可以推断出，在服务端提供重定向访问的服务如RedirectView.setURL等，容易存在SSRF漏洞 OK，这篇文章的内容就先到这，后面再补充一些安全相关的知识","link":"2024/06/05/%E5%B8%B8%E8%A7%81%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"并发编程","slug":"并发编程","link":"tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"源码解析","slug":"源码解析","link":"tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"Lattice","slug":"Lattice","link":"tags/Lattice/"},{"name":"ABE","slug":"ABE","link":"tags/ABE/"},{"name":"工具","slug":"工具","link":"tags/%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"hexo","link":"tags/hexo/"},{"name":"安全","slug":"安全","link":"tags/%E5%AE%89%E5%85%A8/"}],"categories":[{"name":"java","slug":"java","link":"categories/java/"},{"name":"基于格的属性基加密","slug":"基于格的属性基加密","link":"categories/%E5%9F%BA%E4%BA%8E%E6%A0%BC%E7%9A%84%E5%B1%9E%E6%80%A7%E5%9F%BA%E5%8A%A0%E5%AF%86/"},{"name":"工作","slug":"工作","link":"categories/%E5%B7%A5%E4%BD%9C/"},{"name":"网络安全","slug":"网络安全","link":"categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"pages":[]}